<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>StepCreator.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jbehave-core</a> &gt; <a href="index.source.html" class="el_package">org.jbehave.core.steps</a> &gt; <span class="el_source">StepCreator.java</span></div><h1>StepCreator.java</h1><pre class="source lang-java linenums">package org.jbehave.core.steps;

import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.lang.builder.ToStringBuilder;
import org.apache.commons.lang.builder.ToStringStyle;
import org.jbehave.core.annotations.AfterScenario.Outcome;
import org.jbehave.core.annotations.Named;
import org.jbehave.core.failures.BeforeOrAfterFailed;
import org.jbehave.core.failures.RestartingScenarioFailure;
import org.jbehave.core.failures.UUIDExceptionWrapper;
import org.jbehave.core.model.ExamplesTable;
import org.jbehave.core.model.Meta;
import org.jbehave.core.parsers.StepMatcher;
import org.jbehave.core.reporters.StoryReporter;

import com.thoughtworks.paranamer.NullParanamer;
import com.thoughtworks.paranamer.Paranamer;

import static java.util.Arrays.asList;
import static org.jbehave.core.steps.AbstractStepResult.failed;
import static org.jbehave.core.steps.AbstractStepResult.ignorable;
import static org.jbehave.core.steps.AbstractStepResult.notPerformed;
import static org.jbehave.core.steps.AbstractStepResult.pending;
import static org.jbehave.core.steps.AbstractStepResult.skipped;
import static org.jbehave.core.steps.AbstractStepResult.successful;

public class StepCreator {

	public static final String PARAMETER_TABLE_START = &quot;\uff3b&quot;;
    public static final String PARAMETER_TABLE_END = &quot;\uff3d&quot;;
    public static final String PARAMETER_VALUE_START = &quot;\uFF5F&quot;;
    public static final String PARAMETER_VALUE_END = &quot;\uFF60&quot;;
    public static final String PARAMETER_VALUE_NEWLINE = &quot;\u2424&quot;;
<span class="fc" id="L42">    public static final UUIDExceptionWrapper NO_FAILURE = new UUIDExceptionWrapper(&quot;no failure&quot;);</span>
	private static final String NEWLINE = &quot;\n&quot;;
    private static final String SPACE = &quot; &quot;;
	private static final String NONE = &quot;&quot;;
    private final Class&lt;?&gt; stepsType;
    private final InjectableStepsFactory stepsFactory;
    private final ParameterConverters parameterConverters;
    private final ParameterControls parameterControls;
    private final Pattern delimitedNamePattern;
    private final StepMatcher stepMatcher;
    private StepMonitor stepMonitor;
<span class="fc" id="L53">    private Paranamer paranamer = new NullParanamer();</span>
<span class="fc" id="L54">    private boolean dryRun = false;</span>

    public StepCreator(Class&lt;?&gt; stepsType, InjectableStepsFactory stepsFactory,
            ParameterConverters parameterConverters, ParameterControls parameterControls, StepMatcher stepMatcher,
<span class="fc" id="L58">            StepMonitor stepMonitor) {</span>
<span class="fc" id="L59">        this.stepsType = stepsType;</span>
<span class="fc" id="L60">        this.stepsFactory = stepsFactory;</span>
<span class="fc" id="L61">        this.parameterConverters = parameterConverters;</span>
<span class="fc" id="L62">        this.parameterControls = parameterControls;</span>
<span class="fc" id="L63">        this.stepMatcher = stepMatcher;</span>
<span class="fc" id="L64">        this.stepMonitor = stepMonitor;</span>
<span class="fc" id="L65">        this.delimitedNamePattern = Pattern.compile(parameterControls.nameDelimiterLeft() + &quot;(\\w+?)&quot;</span>
                + parameterControls.nameDelimiterRight());
<span class="fc" id="L67">    }</span>

    public void useStepMonitor(StepMonitor stepMonitor) {
<span class="fc" id="L70">        this.stepMonitor = stepMonitor;</span>
<span class="fc" id="L71">    }</span>

    public void useParanamer(Paranamer paranamer) {
<span class="fc" id="L74">        this.paranamer = paranamer;</span>
<span class="fc" id="L75">    }</span>

    public void doDryRun(boolean dryRun) {
<span class="fc" id="L78">        this.dryRun = dryRun;</span>
<span class="fc" id="L79">    }</span>

    public Object stepsInstance() {
<span class="fc" id="L82">        return stepsFactory.createInstanceOfType(stepsType);</span>
    }

    public Step createBeforeOrAfterStep(Method method, Meta meta) {
<span class="fc" id="L86">        return new BeforeOrAfterStep(method, meta);</span>
    }

    public Step createAfterStepUponOutcome(final Method method, final Outcome outcome, Meta storyAndScenarioMeta) {
<span class="pc bfc" id="L90" title="All 3 branches covered.">        switch (outcome) {</span>
        case ANY:
        default:
<span class="fc" id="L93">            return new BeforeOrAfterStep(method, storyAndScenarioMeta);</span>
        case SUCCESS:
<span class="fc" id="L95">            return new SuccessStep(method, storyAndScenarioMeta);</span>
        case FAILURE:
<span class="fc" id="L97">            return new FailureStep(method, storyAndScenarioMeta);</span>
        }
    }

    public Map&lt;String, String&gt; matchedParameters(final Method method, final String stepAsString,
            final String stepWithoutStartingWord, final Map&lt;String, String&gt; namedParameters) {
<span class="fc" id="L103">        Map&lt;String, String&gt; matchedParameters = new HashMap&lt;String, String&gt;(); </span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">        if (stepMatcher.find(stepWithoutStartingWord)) { </span>
            // we've found a match, populate map
<span class="fc" id="L106">            ParameterName[] parameterNames = parameterNames(method);</span>
<span class="fc" id="L107">            Type[] types = method.getGenericParameterTypes();</span>
<span class="fc" id="L108">            String[] values = parameterValuesForStep(namedParameters, types, parameterNames);</span>
    
            
<span class="fc bfc" id="L111" title="All 2 branches covered.">            for (int i = 0; i &lt; parameterNames.length; i++) {</span>
<span class="fc" id="L112">                String name = parameterNames[i].name;</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">                if (name == null) {</span>
<span class="nc" id="L114">                    name = stepMatcher.parameterNames()[i];</span>
                }
<span class="fc" id="L116">                matchedParameters.put(name, values[i]);</span>
            }
        }
        // else return empty map
<span class="fc" id="L120">        return matchedParameters; </span>
    }

    /**
     * Returns the {@link ParameterName} representations for the method,
     * providing an abstraction that supports both annotated and non-annotated
     * parameters.
     * 
     * @param method the Method
     * @return The array of {@link ParameterName}s
     */
    private ParameterName[] parameterNames(Method method) {
<span class="fc" id="L132">        String[] annotatedNames = annotatedParameterNames(method);</span>
<span class="fc" id="L133">        String[] paranamerNames = paranamerParameterNames(method);</span>

<span class="fc" id="L135">        ParameterName[] parameterNames = new ParameterName[annotatedNames.length];</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">        for (int i = 0; i &lt; annotatedNames.length; i++) {</span>
<span class="fc" id="L137">            parameterNames[i] = parameterName(annotatedNames, paranamerNames, i);</span>
        }
<span class="fc" id="L139">        return parameterNames;</span>
    }

    private ParameterName parameterName(String[] annotatedNames, String[] paranamerNames, int i) {
<span class="fc" id="L143">        String name = annotatedNames[i];</span>
<span class="fc" id="L144">        boolean annotated = true;</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">        if (name == null) {</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">            name = (paranamerNames.length &gt; i ? paranamerNames[i] : null);</span>
<span class="fc" id="L147">            annotated = false;</span>
        }
<span class="fc" id="L149">        return new ParameterName(name, annotated);</span>
    }

    /**
     * Extract parameter names using {@link Named}-annotated parameters
     * 
     * @param method the Method with {@link Named}-annotated parameters
     * @return An array of annotated parameter names, which &lt;b&gt;may&lt;/b&gt; include
     *         &lt;code&gt;null&lt;/code&gt; values for parameters that are not annotated
     */
    private String[] annotatedParameterNames(Method method) {
<span class="fc" id="L160">        Annotation[][] parameterAnnotations = method.getParameterAnnotations();</span>
<span class="fc" id="L161">        String[] names = new String[parameterAnnotations.length];</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">        for (int i = 0; i &lt; parameterAnnotations.length; i++) {</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">            for (Annotation annotation : parameterAnnotations[i]) {</span>
<span class="fc" id="L164">                names[i] = annotationName(annotation);</span>
            }
        }
<span class="fc" id="L167">        return names;</span>
    }

    /**
     * Returns either the value of the annotation, either {@link Named} or
     * &quot;javax.inject.Named&quot;.
     * 
     * @param annotation the Annotation
     * @return The annotated value or &lt;code&gt;null&lt;/code&gt; if no annotation is
     *         found
     */
    private String annotationName(Annotation annotation) {
<span class="fc bfc" id="L179" title="All 2 branches covered.">        if (annotation.annotationType().isAssignableFrom(Named.class)) {</span>
<span class="fc" id="L180">            return ((Named) annotation).value();</span>
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">        } else if (&quot;javax.inject.Named&quot;.equals(annotation.annotationType().getName())) {</span>
<span class="fc" id="L182">            return Jsr330Helper.getNamedValue(annotation);</span>
        } else {
<span class="nc" id="L184">            return null;</span>
        }
    }

    /**
     * Extract parameter names using
     * {@link Paranamer#lookupParameterNames(AccessibleObject, boolean)}
     * 
     * @param method the Method inspected by Paranamer
     * @return An array of parameter names looked up by Paranamer
     */
    private String[] paranamerParameterNames(Method method) {
<span class="fc" id="L196">        return paranamer.lookupParameterNames(method, false);</span>
    }

    public Step createParametrisedStep(final Method method, final String stepAsString,
            final String stepWithoutStartingWord, final Map&lt;String, String&gt; namedParameters) {
<span class="fc" id="L201">        return new ParameterisedStep(stepAsString, method, stepWithoutStartingWord, namedParameters);</span>
    }

    private String parametrisedStep(String stepAsString, Map&lt;String, String&gt; namedParameters, Type[] types,
            ParameterName[] names, String[] parameterValues) {
<span class="fc" id="L206">    	String parametrisedStep = stepAsString;</span>
    	// mark parameter values that are parsed
<span class="fc bfc" id="L208" title="All 2 branches covered.">        for (int position = 0; position &lt; types.length; position++) {</span>
<span class="fc" id="L209">            parametrisedStep = markParsedParameterValue(parametrisedStep, types[position], parameterValues[position]);</span>
        }
        // mark parameter values that are named
<span class="fc bfc" id="L212" title="All 2 branches covered.">        for (String name : namedParameters.keySet()) {</span>
<span class="fc" id="L213">            parametrisedStep = markNamedParameterValue(parametrisedStep, namedParameters, name);</span>
<span class="fc" id="L214">        }</span>

<span class="fc" id="L216">        return parametrisedStep;</span>
    }

    private String markNamedParameterValue(String stepText, Map&lt;String, String&gt; namedParameters, String name) {
<span class="fc" id="L220">        String value = namedParameter(namedParameters, name);</span>
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">        if (value != null) {</span>
<span class="fc" id="L222">			stepText = stepText.replace(delimitedName(name), markedValue(value));</span>
        }
<span class="fc" id="L224">        return stepText;</span>
    }

	private String delimitedName(String name) {
<span class="fc" id="L228">		return parameterControls.nameDelimiterLeft() + name + parameterControls.nameDelimiterRight();</span>
	}

    private String markParsedParameterValue(String stepText, Type type, String value) {
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">        if (value != null) {</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">            if (isTable(type)) {</span>
<span class="nc" id="L234">                stepText = stepText.replace(value, markedTable(value));</span>
            } else {
                // only mark non-empty string as parameter (JBEHAVE-656)            	
<span class="fc bfc" id="L237" title="All 2 branches covered.">                if (value.trim().length() != 0) {</span>
<span class="fc" id="L238">                	String markedValue = markedValue(value);</span>
                	// identify parameter values to mark as padded by spaces to avoid duplicated replacements of overlapping values (JBEHAVE-837)
<span class="fc" id="L240">                	String leftPad = SPACE;</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">                	String rightPad = ( stepText.endsWith(value) ? NONE : SPACE );</span>
<span class="fc" id="L242">            		stepText = stepText.replace(pad(value, leftPad, rightPad), pad(markedValue, leftPad, rightPad));</span>
                }
<span class="fc" id="L244">                stepText = stepText.replace(NEWLINE, PARAMETER_VALUE_NEWLINE);</span>
            }
        }
<span class="fc" id="L247">        return stepText;</span>
    }

	private String markedTable(String value) {
<span class="nc" id="L251">		return pad(value, PARAMETER_TABLE_START, PARAMETER_TABLE_END);</span>
	}

	private String markedValue(String value) {
<span class="fc" id="L255">		return pad(value, PARAMETER_VALUE_START, PARAMETER_VALUE_END);</span>
	}

	private String pad(String value, String left, String right){
<span class="fc" id="L259">		return new StringBuilder().append(left).append(value).append(right).toString();</span>
	}
	
    private boolean isTable(Type type) {
<span class="pc bpc" id="L263" title="1 of 4 branches missed.">        return type instanceof Class &amp;&amp; ((Class&lt;?&gt;) type).isAssignableFrom(ExamplesTable.class);</span>
    }

    private String[] parameterValuesForStep(Map&lt;String, String&gt; namedParameters, Type[] types, ParameterName[] names) {
<span class="fc" id="L267">        final String[] parameters = new String[types.length];</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">        for (int position = 0; position &lt; types.length; position++) {</span>
<span class="fc" id="L269">            parameters[position] = parameterForPosition(position, names, namedParameters);</span>
        }
<span class="fc" id="L271">        return parameters;</span>
    }

    private Object[] convertParameterValues(String[] valuesAsString, Type[] types) {
<span class="fc" id="L275">        final Object[] parameters = new Object[valuesAsString.length];</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">        for (int position = 0; position &lt; valuesAsString.length; position++) {</span>
<span class="fc" id="L277">            parameters[position] = parameterConverters.convert(valuesAsString[position], types[position]);</span>
        }
<span class="fc" id="L279">        return parameters;</span>
    }

    private String parameterForPosition(int position, ParameterName[] names, Map&lt;String, String&gt; namedParameters) {
<span class="fc" id="L283">        int namePosition = parameterPosition(names, position);</span>
<span class="fc" id="L284">        String parameter = null;</span>

<span class="fc bfc" id="L286" title="All 2 branches covered.">        if (namePosition != -1) {</span>
<span class="fc" id="L287">            String name = names[position].name;</span>
<span class="fc" id="L288">            boolean annotated = names[position].annotated;</span>

<span class="fc" id="L290">            boolean delimitedNamedParameters = false;</span>

<span class="fc bfc" id="L292" title="All 2 branches covered.">            if (isGroupName(name)) {</span>
<span class="fc" id="L293">                parameter = matchedParameter(name);</span>
<span class="fc" id="L294">                String delimitedName = delimitedNameFor(parameter);</span>

<span class="pc bpc" id="L296" title="1 of 2 branches missed.">                if (delimitedName != null) {</span>
<span class="nc" id="L297">                    name = delimitedName;</span>
<span class="nc" id="L298">                    delimitedNamedParameters = true;</span>
                } else {
<span class="fc" id="L300">                    monitorUsingNameForParameter(name, position, annotated);</span>
                }
            }

<span class="pc bpc" id="L304" title="1 of 4 branches missed.">            if (delimitedNamedParameters || isTableName(namedParameters, name)) {</span>
<span class="fc" id="L305">                monitorUsingTableNameForParameter(name, position, annotated);</span>
<span class="fc" id="L306">                parameter = namedParameter(namedParameters, name);</span>
            }

        }

<span class="fc bfc" id="L311" title="All 2 branches covered.">        if (parameter == null) {</span>
<span class="fc" id="L312">            stepMonitor.usingNaturalOrderForParameter(position);</span>
<span class="fc" id="L313">            parameter = matchedParameter(position);</span>
<span class="fc" id="L314">            String delimitedName = delimitedNameFor(parameter);</span>

<span class="pc bpc" id="L316" title="1 of 4 branches missed.">            if (delimitedName != null &amp;&amp; isTableName(namedParameters, delimitedName)) {</span>
<span class="fc" id="L317">                parameter = namedParameter(namedParameters, delimitedName);</span>
            }
        }

<span class="fc" id="L321">        stepMonitor.foundParameter(parameter, position);</span>

<span class="fc" id="L323">        return parameter;</span>
    }

    private void monitorUsingTableNameForParameter(String name, int position, boolean usingAnnotationNames) {
<span class="fc bfc" id="L327" title="All 2 branches covered.">        if (usingAnnotationNames) {</span>
<span class="fc" id="L328">            stepMonitor.usingTableAnnotatedNameForParameter(name, position);</span>
        } else {
<span class="fc" id="L330">            stepMonitor.usingTableParameterNameForParameter(name, position);</span>
        }
<span class="fc" id="L332">    }</span>

    private void monitorUsingNameForParameter(String name, int position, boolean usingAnnotationNames) {
<span class="fc bfc" id="L335" title="All 2 branches covered.">        if (usingAnnotationNames) {</span>
<span class="fc" id="L336">            stepMonitor.usingAnnotatedNameForParameter(name, position);</span>
        } else {
<span class="fc" id="L338">            stepMonitor.usingParameterNameForParameter(name, position);</span>
        }
<span class="fc" id="L340">    }</span>

    private String delimitedNameFor(String parameter) {
<span class="fc bfc" id="L343" title="All 2 branches covered.">        if ( !parameterControls.delimiterNamedParameters() ){</span>
<span class="fc" id="L344">            return null;</span>
        }
<span class="fc" id="L346">        Matcher matcher = delimitedNamePattern.matcher(parameter);</span>
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">        return matcher.matches() ? matcher.group(1) : null;</span>
    }

    String matchedParameter(String name) {
<span class="fc" id="L351">        String[] parameterNames = stepMatcher.parameterNames();</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">        for (int i = 0; i &lt; parameterNames.length; i++) {</span>
<span class="fc" id="L353">            String parameterName = parameterNames[i];</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">            if (name.equals(parameterName)) {</span>
<span class="fc" id="L355">                return matchedParameter(i);</span>
            }
        }
<span class="fc" id="L358">        throw new ParameterNotFound(name, parameterNames);</span>
    }

    private String matchedParameter(int position) {
<span class="fc" id="L362">        String[] parameterNames = stepMatcher.parameterNames();</span>
<span class="fc" id="L363">        int matchedPosition = position + 1;</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">        if (matchedPosition &lt;= parameterNames.length) {</span>
<span class="fc" id="L365">            return stepMatcher.parameter(matchedPosition);</span>
        }
<span class="fc" id="L367">        throw new ParameterNotFound(position, parameterNames);</span>
    }

    private int parameterPosition(ParameterName[] names, int position) {
<span class="pc bpc" id="L371" title="1 of 2 branches missed.">        if (names.length == 0) {</span>
<span class="nc" id="L372">            return -1;</span>
        }
<span class="fc" id="L374">        String positionName = names[position].name;</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">        for (int i = 0; i &lt; names.length; i++) {</span>
<span class="fc" id="L376">            String name = names[i].name;</span>
<span class="fc bfc" id="L377" title="All 4 branches covered.">            if (name != null &amp;&amp; positionName.equals(name)) {</span>
<span class="fc" id="L378">                return i;</span>
            }
        }
<span class="fc" id="L381">        return -1;</span>
    }

    private boolean isGroupName(String name) {
<span class="fc" id="L385">        String[] groupNames = stepMatcher.parameterNames();</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">        for (String groupName : groupNames) {</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">            if (name.equals(groupName)) {</span>
<span class="fc" id="L388">                return true;</span>
            }
        }
<span class="fc" id="L391">        return false;</span>
    }

    private String namedParameter(Map&lt;String, String&gt; namedParameters, String name) {
<span class="fc" id="L395">        return namedParameters.get(name);</span>
    }

    private boolean isTableName(Map&lt;String, String&gt; namedParameters, String name) {
<span class="fc bfc" id="L399" title="All 2 branches covered.">        return namedParameter(namedParameters, name) != null;</span>
    }

    public static Step createPendingStep(final String stepAsString, String previousNonAndStep) {
<span class="fc" id="L403">        return new PendingStep(stepAsString, previousNonAndStep);</span>
    }

    public static Step createIgnorableStep(final String stepAsString) {
<span class="fc" id="L407">        return new IgnorableStep(stepAsString);</span>
    }

    /**
     * This is a different class, because the @Inject jar may not be in the
     * classpath.
     */
<span class="nc" id="L414">    public static class Jsr330Helper {</span>

        private static String getNamedValue(Annotation annotation) {
<span class="fc" id="L417">            return ((javax.inject.Named) annotation).value();</span>
        }

    }

    @SuppressWarnings(&quot;serial&quot;)
    public static class ParameterNotFound extends RuntimeException {

        public ParameterNotFound(String name, String[] parameters) {
<span class="fc" id="L426">            super(&quot;Parameter not found for name '&quot; + name + &quot;' amongst '&quot; + asList(parameters) + &quot;'&quot;);</span>
<span class="fc" id="L427">        }</span>

        public ParameterNotFound(int position, String[] parameters) {
<span class="fc" id="L430">            super(&quot;Parameter not found for position '&quot; + position + &quot;' amongst '&quot; + asList(parameters) + &quot;'&quot;);</span>
<span class="fc" id="L431">        }</span>
    }

<span class="fc" id="L434">    public static abstract class AbstractStep implements Step {</span>

        @Override
        public String toString() {
<span class="nc" id="L438">            return ToStringBuilder.reflectionToString(this, ToStringStyle.SIMPLE_STYLE);</span>
        }

    }

    private class BeforeOrAfterStep extends AbstractStep {
        private final Method method;
        private final Meta meta;

<span class="fc" id="L447">        public BeforeOrAfterStep(Method method, Meta meta) {</span>
<span class="fc" id="L448">            this.method = method;</span>
<span class="fc" id="L449">            this.meta = meta;</span>
<span class="fc" id="L450">        }</span>

        public StepResult perform(UUIDExceptionWrapper storyFailureIfItHappened) {
<span class="fc" id="L453">            ParameterConverters paramConvertersWithExceptionInjector = paramConvertersWithExceptionInjector(storyFailureIfItHappened);</span>
<span class="fc" id="L454">            MethodInvoker methodInvoker = new MethodInvoker(method, paramConvertersWithExceptionInjector, paranamer,</span>
                    meta);

            try {
<span class="fc" id="L458">                methodInvoker.invoke();</span>
<span class="fc" id="L459">            } catch (InvocationTargetException e) {</span>
<span class="fc" id="L460">                return failed(method, new UUIDExceptionWrapper(new BeforeOrAfterFailed(method, e.getCause())));</span>
<span class="nc" id="L461">            } catch (Throwable t) {</span>
<span class="nc" id="L462">                return failed(method, new UUIDExceptionWrapper(new BeforeOrAfterFailed(method, t)));</span>
<span class="fc" id="L463">            }</span>

<span class="fc" id="L465">            return skipped();</span>
        }

        private ParameterConverters paramConvertersWithExceptionInjector(UUIDExceptionWrapper storyFailureIfItHappened) {
<span class="fc" id="L469">            return parameterConverters.newInstanceAdding(new UUIDExceptionWrapperInjector(storyFailureIfItHappened));</span>
        }

        public StepResult doNotPerform(UUIDExceptionWrapper storyFailureIfItHappened) {
<span class="fc" id="L473">            return perform(storyFailureIfItHappened);</span>
        }

        private class UUIDExceptionWrapperInjector implements ParameterConverters.ParameterConverter {
            private final UUIDExceptionWrapper storyFailureIfItHappened;

<span class="fc" id="L479">            public UUIDExceptionWrapperInjector(UUIDExceptionWrapper storyFailureIfItHappened) {</span>
<span class="fc" id="L480">                this.storyFailureIfItHappened = storyFailureIfItHappened;</span>
<span class="fc" id="L481">            }</span>

            public boolean accept(Type type) {
<span class="pc bpc" id="L484" title="1 of 2 branches missed.">                return UUIDExceptionWrapper.class == type;</span>
            }

            public Object convertValue(String value, Type type) {
<span class="fc" id="L488">                return storyFailureIfItHappened;</span>
            }
        }
    }

    public class SuccessStep extends AbstractStep {
        private BeforeOrAfterStep beforeOrAfterStep;

<span class="fc" id="L496">        public SuccessStep(Method method, Meta storyAndScenarioMeta) {</span>
<span class="fc" id="L497">            this.beforeOrAfterStep = new BeforeOrAfterStep(method, storyAndScenarioMeta);</span>
<span class="fc" id="L498">        }</span>

        public StepResult doNotPerform(UUIDExceptionWrapper storyFailureIfItHappened) {
<span class="fc" id="L501">            return skipped();</span>
        }

        public StepResult perform(UUIDExceptionWrapper storyFailureIfItHappened) {
<span class="fc" id="L505">            return beforeOrAfterStep.perform(storyFailureIfItHappened);</span>
        }
    }

    public class FailureStep extends AbstractStep {
        private final BeforeOrAfterStep beforeOrAfterStep;

<span class="fc" id="L512">        public FailureStep(Method method, Meta storyAndScenarioMeta) {</span>
<span class="fc" id="L513">            this.beforeOrAfterStep = new BeforeOrAfterStep(method, storyAndScenarioMeta);</span>
<span class="fc" id="L514">        }</span>

        public StepResult doNotPerform(UUIDExceptionWrapper storyFailureIfItHappened) {
<span class="fc" id="L517">            return beforeOrAfterStep.perform(storyFailureIfItHappened);</span>
        }

        public StepResult perform(UUIDExceptionWrapper storyFailureIfItHappened) {
<span class="fc" id="L521">            return skipped();</span>
        }
    }

    public class ParameterisedStep extends AbstractStep {
        private Object[] convertedParameters;
        private String parametrisedStep;
        private final String stepAsString;
        private final Method method;
        private final String stepWithoutStartingWord;
        private final Map&lt;String, String&gt; namedParameters;

        public ParameterisedStep(String stepAsString, Method method, String stepWithoutStartingWord,
<span class="fc" id="L534">                Map&lt;String, String&gt; namedParameters) {</span>
<span class="fc" id="L535">            this.stepAsString = stepAsString;</span>
<span class="fc" id="L536">            this.method = method;</span>
<span class="fc" id="L537">            this.stepWithoutStartingWord = stepWithoutStartingWord;</span>
<span class="fc" id="L538">            this.namedParameters = namedParameters;</span>
<span class="fc" id="L539">        }</span>

        public void describeTo(StoryReporter storyReporter) {
<span class="fc" id="L542">            storyReporter.beforeStep(stepAsString);</span>
<span class="fc" id="L543">        }</span>

        public StepResult perform(UUIDExceptionWrapper storyFailureIfItHappened) {
            try {
<span class="fc" id="L547">                parametriseStep();</span>
<span class="fc" id="L548">                stepMonitor.performing(parametrisedStep, dryRun);</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">                if (!dryRun) {</span>
<span class="fc" id="L550">                    method.invoke(stepsInstance(), convertedParameters);</span>
                }
<span class="fc" id="L552">                return successful(stepAsString).withParameterValues(parametrisedStep);</span>
<span class="fc" id="L553">            } catch (ParameterNotFound e) {</span>
                // step parametrisation failed, return pending StepResult
<span class="fc" id="L555">                return pending(stepAsString).withParameterValues(parametrisedStep);</span>
<span class="fc" id="L556">            } catch (InvocationTargetException e) {</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">                if (e.getCause() instanceof RestartingScenarioFailure) {</span>
<span class="fc" id="L558">                    throw (RestartingScenarioFailure) e.getCause();</span>
                }
<span class="fc" id="L560">                Throwable failureCause = e.getCause();</span>
<span class="pc bpc" id="L561" title="1 of 2 branches missed.">                if (failureCause instanceof UUIDExceptionWrapper) {</span>
<span class="fc" id="L562">                    failureCause = failureCause.getCause();</span>
                }
<span class="fc" id="L564">                return failed(stepAsString, new UUIDExceptionWrapper(stepAsString, failureCause)).withParameterValues(</span>
                        parametrisedStep);
<span class="fc" id="L566">            } catch (Throwable t) {</span>
<span class="fc" id="L567">                return failed(stepAsString, new UUIDExceptionWrapper(stepAsString, t)).withParameterValues(</span>
                        parametrisedStep);
            }
        }

        public StepResult doNotPerform(UUIDExceptionWrapper storyFailureIfItHappened) {
            try {
<span class="nc" id="L574">                parametriseStep();</span>
                // } catch (ParameterNotFound e) {
<span class="fc" id="L576">            } catch (Throwable t) {</span>
                // step parametrisation failed, but still return
                // notPerformed StepResult
<span class="nc" id="L579">            }</span>
<span class="fc" id="L580">            return notPerformed(stepAsString).withParameterValues(parametrisedStep);</span>
        }

        private void parametriseStep() {
<span class="fc" id="L584">            stepMatcher.find(stepWithoutStartingWord);</span>
<span class="fc" id="L585">            ParameterName[] names = parameterNames(method);</span>
<span class="fc" id="L586">            Type[] types = method.getGenericParameterTypes();</span>
<span class="fc" id="L587">            String[] parameterValues = parameterValuesForStep(namedParameters, types, names);</span>
<span class="fc" id="L588">            convertedParameters = convertParameterValues(parameterValues, types);</span>
<span class="fc" id="L589">            addNamedParametersToExamplesTables();</span>
<span class="fc" id="L590">            parametrisedStep = parametrisedStep(stepAsString, namedParameters, types, names, parameterValues);</span>
<span class="fc" id="L591">        }</span>

        private void addNamedParametersToExamplesTables() {
<span class="fc bfc" id="L594" title="All 2 branches covered.">            for (Object object : convertedParameters) {</span>
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">                if (object instanceof ExamplesTable) {</span>
<span class="nc" id="L596">                    ((ExamplesTable) object).withNamedParameters(namedParameters);</span>
                }
            }
<span class="fc" id="L599">        }</span>

    }

    public static class PendingStep extends AbstractStep {
        private final String stepAsString;
        private final String previousNonAndStep;
        private Method method;

<span class="fc" id="L608">        public PendingStep(String stepAsString, String previousNonAndStep) {</span>
<span class="fc" id="L609">            this.stepAsString = stepAsString;</span>
<span class="fc" id="L610">            this.previousNonAndStep = previousNonAndStep;</span>
<span class="fc" id="L611">        }</span>

        public StepResult perform(UUIDExceptionWrapper storyFailureIfItHappened) {
<span class="fc" id="L614">            return pending(stepAsString);</span>
        }

        public StepResult doNotPerform(UUIDExceptionWrapper storyFailureIfItHappened) {
<span class="fc" id="L618">            return pending(stepAsString);</span>
        }

        public String stepAsString() {
<span class="fc" id="L622">            return stepAsString;</span>
        }

        public String previousNonAndStepAsString() {
<span class="fc" id="L626">            return previousNonAndStep;</span>
        }

        public void annotatedOn(Method method) {
<span class="nc" id="L630">            this.method = method;</span>
<span class="nc" id="L631">        }</span>

        public boolean annotated() {
<span class="nc bnc" id="L634" title="All 2 branches missed.">            return method != null;</span>
        }

    }

    public static class IgnorableStep extends AbstractStep {
        private final String stepAsString;

<span class="fc" id="L642">        public IgnorableStep(String stepAsString) {</span>
<span class="fc" id="L643">            this.stepAsString = stepAsString;</span>
<span class="fc" id="L644">        }</span>

        public StepResult perform(UUIDExceptionWrapper storyFailureIfItHappened) {
<span class="fc" id="L647">            return ignorable(stepAsString);</span>
        }

        public StepResult doNotPerform(UUIDExceptionWrapper storyFailureIfItHappened) {
<span class="fc" id="L651">            return ignorable(stepAsString);</span>
        }
    }

    private class MethodInvoker {
        private final Method method;
        private final ParameterConverters parameterConverters;
        private final Paranamer paranamer;
        private final Meta meta;
        private int methodArity;

<span class="fc" id="L662">        public MethodInvoker(Method method, ParameterConverters parameterConverters, Paranamer paranamer, Meta meta) {</span>
<span class="fc" id="L663">            this.method = method;</span>
<span class="fc" id="L664">            this.parameterConverters = parameterConverters;</span>
<span class="fc" id="L665">            this.paranamer = paranamer;</span>
<span class="fc" id="L666">            this.meta = meta;</span>
<span class="fc" id="L667">            this.methodArity = method.getParameterTypes().length;</span>
<span class="fc" id="L668">        }</span>

        public void invoke() throws InvocationTargetException, IllegalAccessException {
<span class="fc" id="L671">            method.invoke(stepsInstance(), parameterValuesFrom(meta));</span>
<span class="fc" id="L672">        }</span>

        private Parameter[] methodParameters() {
<span class="fc" id="L675">            Parameter[] parameters = new Parameter[methodArity];</span>
<span class="fc" id="L676">            String[] annotationNamedParameters = annotatedParameterNames(method);</span>
<span class="fc" id="L677">            String[] parameterNames = paranamer.lookupParameterNames(method, false);</span>
<span class="fc" id="L678">            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span>

<span class="fc bfc" id="L680" title="All 2 branches covered.">            for (int paramPosition = 0; paramPosition &lt; methodArity; paramPosition++) {</span>
<span class="fc" id="L681">                String paramName = parameterNameFor(paramPosition, annotationNamedParameters, parameterNames);</span>
<span class="fc" id="L682">                parameters[paramPosition] = new Parameter(paramPosition, parameterTypes[paramPosition], paramName);</span>
            }

<span class="fc" id="L685">            return parameters;</span>
        }

        private String parameterNameFor(int paramPosition, String[] annotationNamedParameters, String[] parameterNames) {
<span class="fc" id="L689">            String nameFromAnnotation = nameIfValidPositionInArray(annotationNamedParameters, paramPosition);</span>
<span class="fc" id="L690">            String parameterName = nameIfValidPositionInArray(parameterNames, paramPosition);</span>
<span class="fc bfc" id="L691" title="All 2 branches covered.">            if (nameFromAnnotation != null) {</span>
<span class="fc" id="L692">                return nameFromAnnotation;</span>
<span class="fc bfc" id="L693" title="All 2 branches covered.">            } else if (parameterName != null) {</span>
<span class="fc" id="L694">                return parameterName;</span>
            }
<span class="fc" id="L696">            return null;</span>
        }

        private String nameIfValidPositionInArray(String[] paramNames, int paramPosition) {
<span class="fc bfc" id="L700" title="All 2 branches covered.">            return paramPosition &lt; paramNames.length ? paramNames[paramPosition] : null;</span>
        }

        private Object[] parameterValuesFrom(Meta meta) {
<span class="fc" id="L704">            Object[] values = new Object[methodArity];</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">            for (Parameter parameter : methodParameters()) {</span>
<span class="fc" id="L706">                values[parameter.position] = parameterConverters.convert(parameter.valueFrom(meta), parameter.type);</span>
            }
<span class="fc" id="L708">            return values;</span>
        }

        private class Parameter {
            private final int position;
            private final Class&lt;?&gt; type;
            private final String name;

<span class="fc" id="L716">            public Parameter(int position, Class&lt;?&gt; type, String name) {</span>
<span class="fc" id="L717">                this.position = position;</span>
<span class="fc" id="L718">                this.type = type;</span>
<span class="fc" id="L719">                this.name = name;</span>
<span class="fc" id="L720">            }</span>

            public String valueFrom(Meta meta) {
<span class="fc bfc" id="L723" title="All 2 branches covered.">                if (name == null) {</span>
<span class="fc" id="L724">                    return null;</span>
                }
<span class="fc" id="L726">                return meta.getProperty(name);</span>
            }
        }
    }

    private static class ParameterName {
        private String name;
        private boolean annotated;

<span class="fc" id="L735">        private ParameterName(String name, boolean annotated) {</span>
<span class="fc" id="L736">            this.name = name;</span>
<span class="fc" id="L737">            this.annotated = annotated;</span>
<span class="fc" id="L738">        }</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.0.201403182114</span></div></body></html>