<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Validate.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">commons-lang3</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.lang3</a> &gt; <span class="el_source">Validate.java</span></div><h1>Validate.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.lang3;

import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.regex.Pattern;

/**
 * &lt;p&gt;This class assists in validating arguments. The validation methods are
 * based along the following principles:
 * &lt;ul&gt;
 *   &lt;li&gt;An invalid {@code null} argument causes a {@link NullPointerException}.&lt;/li&gt;
 *   &lt;li&gt;A non-{@code null} argument causes an {@link IllegalArgumentException}.&lt;/li&gt;
 *   &lt;li&gt;An invalid index into an array/collection/map/string causes an {@link IndexOutOfBoundsException}.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;All exceptions messages are
 * &lt;a href=&quot;http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Formatter.html#syntax&quot;&gt;format strings&lt;/a&gt;
 * as defined by the Java platform. For example:&lt;/p&gt;
 *
 * &lt;pre&gt;
 * Validate.isTrue(i &gt; 0, &quot;The value must be greater than zero: %d&quot;, i);
 * Validate.notNull(surname, &quot;The surname must not be %s&quot;, null);
 * &lt;/pre&gt;
 *
 * &lt;p&gt;#ThreadSafe#&lt;/p&gt;
 * @version $Id: Validate.java 1459653 2013-03-22 07:37:03Z bayard $
 * @see java.lang.String#format(String, Object...)
 * @since 2.0
 */
public class Validate {

    private static final String DEFAULT_EXCLUSIVE_BETWEEN_EX_MESSAGE =
        &quot;The value %s is not in the specified exclusive range of %s to %s&quot;;
    private static final String DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE =
        &quot;The value %s is not in the specified inclusive range of %s to %s&quot;;
    private static final String DEFAULT_MATCHES_PATTERN_EX = &quot;The string %s does not match the pattern %s&quot;;
    private static final String DEFAULT_IS_NULL_EX_MESSAGE = &quot;The validated object is null&quot;;
    private static final String DEFAULT_IS_TRUE_EX_MESSAGE = &quot;The validated expression is false&quot;;
    private static final String DEFAULT_NO_NULL_ELEMENTS_ARRAY_EX_MESSAGE =
        &quot;The validated array contains null element at index: %d&quot;;
    private static final String DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE =
        &quot;The validated collection contains null element at index: %d&quot;;
    private static final String DEFAULT_NOT_BLANK_EX_MESSAGE = &quot;The validated character sequence is blank&quot;;
    private static final String DEFAULT_NOT_EMPTY_ARRAY_EX_MESSAGE = &quot;The validated array is empty&quot;;
    private static final String DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE =
        &quot;The validated character sequence is empty&quot;;
    private static final String DEFAULT_NOT_EMPTY_COLLECTION_EX_MESSAGE = &quot;The validated collection is empty&quot;;
    private static final String DEFAULT_NOT_EMPTY_MAP_EX_MESSAGE = &quot;The validated map is empty&quot;;
    private static final String DEFAULT_VALID_INDEX_ARRAY_EX_MESSAGE = &quot;The validated array index is invalid: %d&quot;;
    private static final String DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE =
        &quot;The validated character sequence index is invalid: %d&quot;;
    private static final String DEFAULT_VALID_INDEX_COLLECTION_EX_MESSAGE =
        &quot;The validated collection index is invalid: %d&quot;;
    private static final String DEFAULT_VALID_STATE_EX_MESSAGE = &quot;The validated state is false&quot;;
    private static final String DEFAULT_IS_ASSIGNABLE_EX_MESSAGE = &quot;Cannot assign a %s to a %s&quot;;
    private static final String DEFAULT_IS_INSTANCE_OF_EX_MESSAGE = &quot;Expected type: %s, actual: %s&quot;;

    /**
     * Constructor. This class should not normally be instantiated.
     */
    public Validate() {
<span class="fc" id="L79">      super();</span>
<span class="fc" id="L80">    }</span>

    // isTrue
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validate that the argument condition is {@code true}; otherwise
     * throwing an exception with the specified message. This method is useful when
     * validating according to an arbitrary boolean expression, such as validating a
     * primitive number or using your own custom validation expression.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.isTrue(i &gt; 0.0, &quot;The value must be greater than zero: %d&quot;, i);&lt;/pre&gt;
     *
     * &lt;p&gt;For performance reasons, the long value is passed as a separate parameter and
     * appended to the exception message only in the case of an error.&lt;/p&gt;
     *
     * @param expression  the boolean expression to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param value  the value to append to the message when invalid
     * @throws IllegalArgumentException if expression is {@code false}
     * @see #isTrue(boolean)
     * @see #isTrue(boolean, String, double)
     * @see #isTrue(boolean, String, Object...)
     */
    public static void isTrue(final boolean expression, final String message, final long value) {
<span class="fc bfc" id="L105" title="All 2 branches covered.">        if (expression == false) {</span>
<span class="fc" id="L106">            throw new IllegalArgumentException(String.format(message, Long.valueOf(value)));</span>
        }
<span class="fc" id="L108">    }</span>

    /**
     * &lt;p&gt;Validate that the argument condition is {@code true}; otherwise
     * throwing an exception with the specified message. This method is useful when
     * validating according to an arbitrary boolean expression, such as validating a
     * primitive number or using your own custom validation expression.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.isTrue(d &gt; 0.0, &quot;The value must be greater than zero: %s&quot;, d);&lt;/pre&gt;
     *
     * &lt;p&gt;For performance reasons, the double value is passed as a separate parameter and
     * appended to the exception message only in the case of an error.&lt;/p&gt;
     *
     * @param expression  the boolean expression to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param value  the value to append to the message when invalid
     * @throws IllegalArgumentException if expression is {@code false}
     * @see #isTrue(boolean)
     * @see #isTrue(boolean, String, long)
     * @see #isTrue(boolean, String, Object...)
     */
    public static void isTrue(final boolean expression, final String message, final double value) {
<span class="fc bfc" id="L130" title="All 2 branches covered.">        if (expression == false) {</span>
<span class="fc" id="L131">            throw new IllegalArgumentException(String.format(message, Double.valueOf(value)));</span>
        }
<span class="fc" id="L133">    }</span>

    /**
     * &lt;p&gt;Validate that the argument condition is {@code true}; otherwise
     * throwing an exception with the specified message. This method is useful when
     * validating according to an arbitrary boolean expression, such as validating a
     * primitive number or using your own custom validation expression.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * Validate.isTrue(i &gt;= min &amp;&amp; i &lt;= max, &quot;The value must be between %d and %d&quot;, min, max);
     * Validate.isTrue(myObject.isOk(), &quot;The object is not okay&quot;);&lt;/pre&gt;
     *
     * @param expression  the boolean expression to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @throws IllegalArgumentException if expression is {@code false}
     * @see #isTrue(boolean)
     * @see #isTrue(boolean, String, long)
     * @see #isTrue(boolean, String, double)
     */
    public static void isTrue(final boolean expression, final String message, final Object... values) {
<span class="fc bfc" id="L154" title="All 2 branches covered.">        if (expression == false) {</span>
<span class="fc" id="L155">            throw new IllegalArgumentException(String.format(message, values));</span>
        }
<span class="fc" id="L157">    }</span>

    /**
     * &lt;p&gt;Validate that the argument condition is {@code true}; otherwise
     * throwing an exception. This method is useful when validating according
     * to an arbitrary boolean expression, such as validating a
     * primitive number or using your own custom validation expression.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * Validate.isTrue(i &gt; 0);
     * Validate.isTrue(myObject.isOk());&lt;/pre&gt;
     *
     * &lt;p&gt;The message of the exception is &amp;quot;The validated expression is
     * false&amp;quot;.&lt;/p&gt;
     *
     * @param expression  the boolean expression to check
     * @throws IllegalArgumentException if expression is {@code false}
     * @see #isTrue(boolean, String, long)
     * @see #isTrue(boolean, String, double)
     * @see #isTrue(boolean, String, Object...)
     */
    public static void isTrue(final boolean expression) {
<span class="fc bfc" id="L179" title="All 2 branches covered.">        if (expression == false) {</span>
<span class="fc" id="L180">            throw new IllegalArgumentException(DEFAULT_IS_TRUE_EX_MESSAGE);</span>
        }
<span class="fc" id="L182">    }</span>

    // notNull
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validate that the specified argument is not {@code null};
     * otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.notNull(myObject, &quot;The object must not be null&quot;);&lt;/pre&gt;
     *
     * &lt;p&gt;The message of the exception is &amp;quot;The validated object is
     * null&amp;quot;.&lt;/p&gt;
     *
     * @param &lt;T&gt; the object type
     * @param object  the object to check
     * @return the validated object (never {@code null} for method chaining)
     * @throws NullPointerException if the object is {@code null}
     * @see #notNull(Object, String, Object...)
     */
    public static &lt;T&gt; T notNull(final T object) {
<span class="fc" id="L203">        return notNull(object, DEFAULT_IS_NULL_EX_MESSAGE);</span>
    }

    /**
     * &lt;p&gt;Validate that the specified argument is not {@code null};
     * otherwise throwing an exception with the specified message.
     *
     * &lt;pre&gt;Validate.notNull(myObject, &quot;The object must not be null&quot;);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the object type
     * @param object  the object to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message
     * @return the validated object (never {@code null} for method chaining)
     * @throws NullPointerException if the object is {@code null}
     * @see #notNull(Object)
     */
    public static &lt;T&gt; T notNull(final T object, final String message, final Object... values) {
<span class="fc bfc" id="L221" title="All 2 branches covered.">        if (object == null) {</span>
<span class="fc" id="L222">            throw new NullPointerException(String.format(message, values));</span>
        }
<span class="fc" id="L224">        return object;</span>
    }

    // notEmpty array
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validate that the specified argument array is neither {@code null}
     * nor a length of zero (no elements); otherwise throwing an exception
     * with the specified message.
     *
     * &lt;pre&gt;Validate.notEmpty(myArray, &quot;The array must not be empty&quot;);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the array type
     * @param array  the array to check, validated not null by this method
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated array (never {@code null} method for chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IllegalArgumentException if the array is empty
     * @see #notEmpty(Object[])
     */
    public static &lt;T&gt; T[] notEmpty(final T[] array, final String message, final Object... values) {
<span class="fc bfc" id="L247" title="All 2 branches covered.">        if (array == null) {</span>
<span class="fc" id="L248">            throw new NullPointerException(String.format(message, values));</span>
        }
<span class="fc bfc" id="L250" title="All 2 branches covered.">        if (array.length == 0) {</span>
<span class="fc" id="L251">            throw new IllegalArgumentException(String.format(message, values));</span>
        }
<span class="fc" id="L253">        return array;</span>
    }

    /**
     * &lt;p&gt;Validate that the specified argument array is neither {@code null}
     * nor a length of zero (no elements); otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.notEmpty(myArray);&lt;/pre&gt;
     *
     * &lt;p&gt;The message in the exception is &amp;quot;The validated array is
     * empty&amp;quot;.
     *
     * @param &lt;T&gt; the array type
     * @param array  the array to check, validated not null by this method
     * @return the validated array (never {@code null} method for chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IllegalArgumentException if the array is empty
     * @see #notEmpty(Object[], String, Object...)
     */
    public static &lt;T&gt; T[] notEmpty(final T[] array) {
<span class="fc" id="L273">        return notEmpty(array, DEFAULT_NOT_EMPTY_ARRAY_EX_MESSAGE);</span>
    }

    // notEmpty collection
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validate that the specified argument collection is neither {@code null}
     * nor a size of zero (no elements); otherwise throwing an exception
     * with the specified message.
     *
     * &lt;pre&gt;Validate.notEmpty(myCollection, &quot;The collection must not be empty&quot;);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the collection type
     * @param collection  the collection to check, validated not null by this method
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated collection (never {@code null} method for chaining)
     * @throws NullPointerException if the collection is {@code null}
     * @throws IllegalArgumentException if the collection is empty
     * @see #notEmpty(Object[])
     */
    public static &lt;T extends Collection&lt;?&gt;&gt; T notEmpty(final T collection, final String message, final Object... values) {
<span class="fc bfc" id="L296" title="All 2 branches covered.">        if (collection == null) {</span>
<span class="fc" id="L297">            throw new NullPointerException(String.format(message, values));</span>
        }
<span class="fc bfc" id="L299" title="All 2 branches covered.">        if (collection.isEmpty()) {</span>
<span class="fc" id="L300">            throw new IllegalArgumentException(String.format(message, values));</span>
        }
<span class="fc" id="L302">        return collection;</span>
    }

    /**
     * &lt;p&gt;Validate that the specified argument collection is neither {@code null}
     * nor a size of zero (no elements); otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.notEmpty(myCollection);&lt;/pre&gt;
     *
     * &lt;p&gt;The message in the exception is &amp;quot;The validated collection is
     * empty&amp;quot;.&lt;/p&gt;
     *
     * @param &lt;T&gt; the collection type
     * @param collection  the collection to check, validated not null by this method
     * @return the validated collection (never {@code null} method for chaining)
     * @throws NullPointerException if the collection is {@code null}
     * @throws IllegalArgumentException if the collection is empty
     * @see #notEmpty(Collection, String, Object...)
     */
    public static &lt;T extends Collection&lt;?&gt;&gt; T notEmpty(final T collection) {
<span class="fc" id="L322">        return notEmpty(collection, DEFAULT_NOT_EMPTY_COLLECTION_EX_MESSAGE);</span>
    }

    // notEmpty map
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validate that the specified argument map is neither {@code null}
     * nor a size of zero (no elements); otherwise throwing an exception
     * with the specified message.
     *
     * &lt;pre&gt;Validate.notEmpty(myMap, &quot;The map must not be empty&quot;);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the map type
     * @param map  the map to check, validated not null by this method
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated map (never {@code null} method for chaining)
     * @throws NullPointerException if the map is {@code null}
     * @throws IllegalArgumentException if the map is empty
     * @see #notEmpty(Object[])
     */
    public static &lt;T extends Map&lt;?, ?&gt;&gt; T notEmpty(final T map, final String message, final Object... values) {
<span class="fc bfc" id="L345" title="All 2 branches covered.">        if (map == null) {</span>
<span class="fc" id="L346">            throw new NullPointerException(String.format(message, values));</span>
        }
<span class="fc bfc" id="L348" title="All 2 branches covered.">        if (map.isEmpty()) {</span>
<span class="fc" id="L349">            throw new IllegalArgumentException(String.format(message, values));</span>
        }
<span class="fc" id="L351">        return map;</span>
    }

    /**
     * &lt;p&gt;Validate that the specified argument map is neither {@code null}
     * nor a size of zero (no elements); otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.notEmpty(myMap);&lt;/pre&gt;
     *
     * &lt;p&gt;The message in the exception is &amp;quot;The validated map is
     * empty&amp;quot;.&lt;/p&gt;
     *
     * @param &lt;T&gt; the map type
     * @param map  the map to check, validated not null by this method
     * @return the validated map (never {@code null} method for chaining)
     * @throws NullPointerException if the map is {@code null}
     * @throws IllegalArgumentException if the map is empty
     * @see #notEmpty(Map, String, Object...)
     */
    public static &lt;T extends Map&lt;?, ?&gt;&gt; T notEmpty(final T map) {
<span class="fc" id="L371">        return notEmpty(map, DEFAULT_NOT_EMPTY_MAP_EX_MESSAGE);</span>
    }

    // notEmpty string
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validate that the specified argument character sequence is
     * neither {@code null} nor a length of zero (no characters);
     * otherwise throwing an exception with the specified message.
     *
     * &lt;pre&gt;Validate.notEmpty(myString, &quot;The string must not be empty&quot;);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the character sequence type
     * @param chars  the character sequence to check, validated not null by this method
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated character sequence (never {@code null} method for chaining)
     * @throws NullPointerException if the character sequence is {@code null}
     * @throws IllegalArgumentException if the character sequence is empty
     * @see #notEmpty(CharSequence)
     */
    public static &lt;T extends CharSequence&gt; T notEmpty(final T chars, final String message, final Object... values) {
<span class="fc bfc" id="L394" title="All 2 branches covered.">        if (chars == null) {</span>
<span class="fc" id="L395">            throw new NullPointerException(String.format(message, values));</span>
        }
<span class="fc bfc" id="L397" title="All 2 branches covered.">        if (chars.length() == 0) {</span>
<span class="fc" id="L398">            throw new IllegalArgumentException(String.format(message, values));</span>
        }
<span class="fc" id="L400">        return chars;</span>
    }

    /**
     * &lt;p&gt;Validate that the specified argument character sequence is
     * neither {@code null} nor a length of zero (no characters);
     * otherwise throwing an exception with the specified message.
     *
     * &lt;pre&gt;Validate.notEmpty(myString);&lt;/pre&gt;
     *
     * &lt;p&gt;The message in the exception is &amp;quot;The validated
     * character sequence is empty&amp;quot;.&lt;/p&gt;
     *
     * @param &lt;T&gt; the character sequence type
     * @param chars  the character sequence to check, validated not null by this method
     * @return the validated character sequence (never {@code null} method for chaining)
     * @throws NullPointerException if the character sequence is {@code null}
     * @throws IllegalArgumentException if the character sequence is empty
     * @see #notEmpty(CharSequence, String, Object...)
     */
    public static &lt;T extends CharSequence&gt; T notEmpty(final T chars) {
<span class="fc" id="L421">        return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE);</span>
    }

    // notBlank string
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validate that the specified argument character sequence is
     * neither {@code null}, a length of zero (no characters), empty
     * nor whitespace; otherwise throwing an exception with the specified
     * message.
     *
     * &lt;pre&gt;Validate.notBlank(myString, &quot;The string must not be blank&quot;);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the character sequence type
     * @param chars  the character sequence to check, validated not null by this method
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated character sequence (never {@code null} method for chaining)
     * @throws NullPointerException if the character sequence is {@code null}
     * @throws IllegalArgumentException if the character sequence is blank
     * @see #notBlank(CharSequence)
     *
     * @since 3.0
     */
    public static &lt;T extends CharSequence&gt; T notBlank(final T chars, final String message, final Object... values) {
<span class="fc bfc" id="L447" title="All 2 branches covered.">        if (chars == null) {</span>
<span class="fc" id="L448">            throw new NullPointerException(String.format(message, values));</span>
        }
<span class="fc bfc" id="L450" title="All 2 branches covered.">        if (StringUtils.isBlank(chars)) {</span>
<span class="fc" id="L451">            throw new IllegalArgumentException(String.format(message, values));</span>
        }
<span class="fc" id="L453">        return chars;</span>
    }

    /**
     * &lt;p&gt;Validate that the specified argument character sequence is
     * neither {@code null}, a length of zero (no characters), empty
     * nor whitespace; otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.notBlank(myString);&lt;/pre&gt;
     *
     * &lt;p&gt;The message in the exception is &amp;quot;The validated character
     * sequence is blank&amp;quot;.&lt;/p&gt;
     *
     * @param &lt;T&gt; the character sequence type
     * @param chars  the character sequence to check, validated not null by this method
     * @return the validated character sequence (never {@code null} method for chaining)
     * @throws NullPointerException if the character sequence is {@code null}
     * @throws IllegalArgumentException if the character sequence is blank
     * @see #notBlank(CharSequence, String, Object...)
     *
     * @since 3.0
     */
    public static &lt;T extends CharSequence&gt; T notBlank(final T chars) {
<span class="fc" id="L476">        return notBlank(chars, DEFAULT_NOT_BLANK_EX_MESSAGE);</span>
    }

    // noNullElements array
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validate that the specified argument array is neither
     * {@code null} nor contains any elements that are {@code null};
     * otherwise throwing an exception with the specified message.
     *
     * &lt;pre&gt;Validate.noNullElements(myArray, &quot;The array contain null at position %d&quot;);&lt;/pre&gt;
     *
     * &lt;p&gt;If the array is {@code null}, then the message in the exception
     * is &amp;quot;The validated object is null&amp;quot;.&lt;/p&gt;
     *
     * &lt;p&gt;If the array has a {@code null} element, then the iteration
     * index of the invalid element is appended to the {@code values}
     * argument.&lt;/p&gt;
     *
     * @param &lt;T&gt; the array type
     * @param array  the array to check, validated not null by this method
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated array (never {@code null} method for chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IllegalArgumentException if an element is {@code null}
     * @see #noNullElements(Object[])
     */
    public static &lt;T&gt; T[] noNullElements(final T[] array, final String message, final Object... values) {
<span class="fc" id="L506">        Validate.notNull(array);</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">        for (int i = 0; i &lt; array.length; i++) {</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">            if (array[i] == null) {</span>
<span class="fc" id="L509">                final Object[] values2 = ArrayUtils.add(values, Integer.valueOf(i));</span>
<span class="fc" id="L510">                throw new IllegalArgumentException(String.format(message, values2));</span>
            }
        }
<span class="fc" id="L513">        return array;</span>
    }

    /**
     * &lt;p&gt;Validate that the specified argument array is neither
     * {@code null} nor contains any elements that are {@code null};
     * otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.noNullElements(myArray);&lt;/pre&gt;
     *
     * &lt;p&gt;If the array is {@code null}, then the message in the exception
     * is &amp;quot;The validated object is null&amp;quot;.&lt;/p&gt;
     *
     * &lt;p&gt;If the array has a {@code null} element, then the message in the
     * exception is &amp;quot;The validated array contains null element at index:
     * &amp;quot followed by the index.&lt;/p&gt;
     *
     * @param &lt;T&gt; the array type
     * @param array  the array to check, validated not null by this method
     * @return the validated array (never {@code null} method for chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IllegalArgumentException if an element is {@code null}
     * @see #noNullElements(Object[], String, Object...)
     */
    public static &lt;T&gt; T[] noNullElements(final T[] array) {
<span class="fc" id="L538">        return noNullElements(array, DEFAULT_NO_NULL_ELEMENTS_ARRAY_EX_MESSAGE);</span>
    }

    // noNullElements iterable
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validate that the specified argument iterable is neither
     * {@code null} nor contains any elements that are {@code null};
     * otherwise throwing an exception with the specified message.
     *
     * &lt;pre&gt;Validate.noNullElements(myCollection, &quot;The collection contains null at position %d&quot;);&lt;/pre&gt;
     *
     * &lt;p&gt;If the iterable is {@code null}, then the message in the exception
     * is &amp;quot;The validated object is null&amp;quot;.&lt;/p&gt;
     *
     * &lt;p&gt;If the iterable has a {@code null} element, then the iteration
     * index of the invalid element is appended to the {@code values}
     * argument.&lt;/p&gt;
     *
     * @param &lt;T&gt; the iterable type
     * @param iterable  the iterable to check, validated not null by this method
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated iterable (never {@code null} method for chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IllegalArgumentException if an element is {@code null}
     * @see #noNullElements(Iterable)
     */
    public static &lt;T extends Iterable&lt;?&gt;&gt; T noNullElements(final T iterable, final String message, final Object... values) {
<span class="fc" id="L568">        Validate.notNull(iterable);</span>
<span class="fc" id="L569">        int i = 0;</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">        for (final Iterator&lt;?&gt; it = iterable.iterator(); it.hasNext(); i++) {</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">            if (it.next() == null) {</span>
<span class="fc" id="L572">                final Object[] values2 = ArrayUtils.addAll(values, Integer.valueOf(i));</span>
<span class="fc" id="L573">                throw new IllegalArgumentException(String.format(message, values2));</span>
            }
        }
<span class="fc" id="L576">        return iterable;</span>
    }

    /**
     * &lt;p&gt;Validate that the specified argument iterable is neither
     * {@code null} nor contains any elements that are {@code null};
     * otherwise throwing an exception.
     *
     * &lt;pre&gt;Validate.noNullElements(myCollection);&lt;/pre&gt;
     *
     * &lt;p&gt;If the iterable is {@code null}, then the message in the exception
     * is &amp;quot;The validated object is null&amp;quot;.&lt;/p&gt;
     *
     * &lt;p&gt;If the array has a {@code null} element, then the message in the
     * exception is &amp;quot;The validated iterable contains null element at index:
     * &amp;quot followed by the index.&lt;/p&gt;
     *
     * @param &lt;T&gt; the iterable type
     * @param iterable  the iterable to check, validated not null by this method
     * @return the validated iterable (never {@code null} method for chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IllegalArgumentException if an element is {@code null}
     * @see #noNullElements(Iterable, String, Object...)
     */
    public static &lt;T extends Iterable&lt;?&gt;&gt; T noNullElements(final T iterable) {
<span class="fc" id="L601">        return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE);</span>
    }

    // validIndex array
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validates that the index is within the bounds of the argument
     * array; otherwise throwing an exception with the specified message.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.validIndex(myArray, 2, &quot;The array index is invalid: &quot;);&lt;/pre&gt;
     *
     * &lt;p&gt;If the array is {@code null}, then the message of the exception
     * is &amp;quot;The validated object is null&amp;quot;.&lt;/p&gt;
     *
     * @param &lt;T&gt; the array type
     * @param array  the array to check, validated not null by this method
     * @param index  the index to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated array (never {@code null} for method chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IndexOutOfBoundsException if the index is invalid
     * @see #validIndex(Object[], int)
     *
     * @since 3.0
     */
    public static &lt;T&gt; T[] validIndex(final T[] array, final int index, final String message, final Object... values) {
<span class="fc" id="L629">        Validate.notNull(array);</span>
<span class="fc bfc" id="L630" title="All 4 branches covered.">        if (index &lt; 0 || index &gt;= array.length) {</span>
<span class="fc" id="L631">            throw new IndexOutOfBoundsException(String.format(message, values));</span>
        }
<span class="fc" id="L633">        return array;</span>
    }

    /**
     * &lt;p&gt;Validates that the index is within the bounds of the argument
     * array; otherwise throwing an exception.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.validIndex(myArray, 2);&lt;/pre&gt;
     *
     * &lt;p&gt;If the array is {@code null}, then the message of the exception
     * is &amp;quot;The validated object is null&amp;quot;.&lt;/p&gt;
     *
     * &lt;p&gt;If the index is invalid, then the message of the exception is
     * &amp;quot;The validated array index is invalid: &amp;quot; followed by the
     * index.&lt;/p&gt;
     *
     * @param &lt;T&gt; the array type
     * @param array  the array to check, validated not null by this method
     * @param index  the index to check
     * @return the validated array (never {@code null} for method chaining)
     * @throws NullPointerException if the array is {@code null}
     * @throws IndexOutOfBoundsException if the index is invalid
     * @see #validIndex(Object[], int, String, Object...)
     *
     * @since 3.0
     */
    public static &lt;T&gt; T[] validIndex(final T[] array, final int index) {
<span class="fc" id="L660">        return validIndex(array, index, DEFAULT_VALID_INDEX_ARRAY_EX_MESSAGE, Integer.valueOf(index));</span>
    }

    // validIndex collection
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validates that the index is within the bounds of the argument
     * collection; otherwise throwing an exception with the specified message.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.validIndex(myCollection, 2, &quot;The collection index is invalid: &quot;);&lt;/pre&gt;
     *
     * &lt;p&gt;If the collection is {@code null}, then the message of the
     * exception is &amp;quot;The validated object is null&amp;quot;.&lt;/p&gt;
     *
     * @param &lt;T&gt; the collection type
     * @param collection  the collection to check, validated not null by this method
     * @param index  the index to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated collection (never {@code null} for chaining)
     * @throws NullPointerException if the collection is {@code null}
     * @throws IndexOutOfBoundsException if the index is invalid
     * @see #validIndex(Collection, int)
     *
     * @since 3.0
     */
    public static &lt;T extends Collection&lt;?&gt;&gt; T validIndex(final T collection, final int index, final String message, final Object... values) {
<span class="fc" id="L688">        Validate.notNull(collection);</span>
<span class="fc bfc" id="L689" title="All 4 branches covered.">        if (index &lt; 0 || index &gt;= collection.size()) {</span>
<span class="fc" id="L690">            throw new IndexOutOfBoundsException(String.format(message, values));</span>
        }
<span class="fc" id="L692">        return collection;</span>
    }

    /**
     * &lt;p&gt;Validates that the index is within the bounds of the argument
     * collection; otherwise throwing an exception.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.validIndex(myCollection, 2);&lt;/pre&gt;
     *
     * &lt;p&gt;If the index is invalid, then the message of the exception
     * is &amp;quot;The validated collection index is invalid: &amp;quot;
     * followed by the index.&lt;/p&gt;
     *
     * @param &lt;T&gt; the collection type
     * @param collection  the collection to check, validated not null by this method
     * @param index  the index to check
     * @return the validated collection (never {@code null} for method chaining)
     * @throws NullPointerException if the collection is {@code null}
     * @throws IndexOutOfBoundsException if the index is invalid
     * @see #validIndex(Collection, int, String, Object...)
     *
     * @since 3.0
     */
    public static &lt;T extends Collection&lt;?&gt;&gt; T validIndex(final T collection, final int index) {
<span class="fc" id="L716">        return validIndex(collection, index, DEFAULT_VALID_INDEX_COLLECTION_EX_MESSAGE, Integer.valueOf(index));</span>
    }

    // validIndex string
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validates that the index is within the bounds of the argument
     * character sequence; otherwise throwing an exception with the
     * specified message.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.validIndex(myStr, 2, &quot;The string index is invalid: &quot;);&lt;/pre&gt;
     *
     * &lt;p&gt;If the character sequence is {@code null}, then the message
     * of the exception is &amp;quot;The validated object is null&amp;quot;.&lt;/p&gt;
     *
     * @param &lt;T&gt; the character sequence type
     * @param chars  the character sequence to check, validated not null by this method
     * @param index  the index to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @return the validated character sequence (never {@code null} for method chaining)
     * @throws NullPointerException if the character sequence is {@code null}
     * @throws IndexOutOfBoundsException if the index is invalid
     * @see #validIndex(CharSequence, int)
     *
     * @since 3.0
     */
    public static &lt;T extends CharSequence&gt; T validIndex(final T chars, final int index, final String message, final Object... values) {
<span class="fc" id="L745">        Validate.notNull(chars);</span>
<span class="fc bfc" id="L746" title="All 4 branches covered.">        if (index &lt; 0 || index &gt;= chars.length()) {</span>
<span class="fc" id="L747">            throw new IndexOutOfBoundsException(String.format(message, values));</span>
        }
<span class="fc" id="L749">        return chars;</span>
    }

    /**
     * &lt;p&gt;Validates that the index is within the bounds of the argument
     * character sequence; otherwise throwing an exception.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.validIndex(myStr, 2);&lt;/pre&gt;
     *
     * &lt;p&gt;If the character sequence is {@code null}, then the message
     * of the exception is &amp;quot;The validated object is
     * null&amp;quot;.&lt;/p&gt;
     *
     * &lt;p&gt;If the index is invalid, then the message of the exception
     * is &amp;quot;The validated character sequence index is invalid: &amp;quot;
     * followed by the index.&lt;/p&gt;
     *
     * @param &lt;T&gt; the character sequence type
     * @param chars  the character sequence to check, validated not null by this method
     * @param index  the index to check
     * @return the validated character sequence (never {@code null} for method chaining)
     * @throws NullPointerException if the character sequence is {@code null}
     * @throws IndexOutOfBoundsException if the index is invalid
     * @see #validIndex(CharSequence, int, String, Object...)
     *
     * @since 3.0
     */
    public static &lt;T extends CharSequence&gt; T validIndex(final T chars, final int index) {
<span class="fc" id="L777">        return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE, Integer.valueOf(index));</span>
    }

    // validState
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validate that the stateful condition is {@code true}; otherwise
     * throwing an exception. This method is useful when validating according
     * to an arbitrary boolean expression, such as validating a
     * primitive number or using your own custom validation expression.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * Validate.validState(field &gt; 0);
     * Validate.validState(this.isOk());&lt;/pre&gt;
     *
     * &lt;p&gt;The message of the exception is &amp;quot;The validated state is
     * false&amp;quot;.&lt;/p&gt;
     *
     * @param expression  the boolean expression to check
     * @throws IllegalStateException if expression is {@code false}
     * @see #validState(boolean, String, Object...)
     *
     * @since 3.0
     */
    public static void validState(final boolean expression) {
<span class="nc bnc" id="L803" title="All 2 branches missed.">        if (expression == false) {</span>
<span class="nc" id="L804">            throw new IllegalStateException(DEFAULT_VALID_STATE_EX_MESSAGE);</span>
        }
<span class="nc" id="L806">    }</span>

    /**
     * &lt;p&gt;Validate that the stateful condition is {@code true}; otherwise
     * throwing an exception with the specified message. This method is useful when
     * validating according to an arbitrary boolean expression, such as validating a
     * primitive number or using your own custom validation expression.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.validState(this.isOk(), &quot;The state is not OK: %s&quot;, myObject);&lt;/pre&gt;
     *
     * @param expression  the boolean expression to check
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @throws IllegalStateException if expression is {@code false}
     * @see #validState(boolean)
     *
     * @since 3.0
     */
    public static void validState(final boolean expression, final String message, final Object... values) {
<span class="nc bnc" id="L825" title="All 2 branches missed.">        if (expression == false) {</span>
<span class="nc" id="L826">            throw new IllegalStateException(String.format(message, values));</span>
        }
<span class="nc" id="L828">    }</span>

    // matchesPattern
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validate that the specified argument character sequence matches the specified regular
     * expression pattern; otherwise throwing an exception.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.matchesPattern(&quot;hi&quot;, &quot;[a-z]*&quot;);&lt;/pre&gt;
     *
     * &lt;p&gt;The syntax of the pattern is the one used in the {@link Pattern} class.&lt;/p&gt;
     *
     * @param input  the character sequence to validate, not null
     * @param pattern  the regular expression pattern, not null
     * @throws IllegalArgumentException if the character sequence does not match the pattern
     * @see #matchesPattern(CharSequence, String, String, Object...)
     *
     * @since 3.0
     */
    public static void matchesPattern(final CharSequence input, final String pattern) {
        // TODO when breaking BC, consider returning input
<span class="fc bfc" id="L850" title="All 2 branches covered.">        if (Pattern.matches(pattern, input) == false) {</span>
<span class="fc" id="L851">            throw new IllegalArgumentException(String.format(DEFAULT_MATCHES_PATTERN_EX, input, pattern));</span>
        }
<span class="fc" id="L853">    }</span>

    /**
     * &lt;p&gt;Validate that the specified argument character sequence matches the specified regular
     * expression pattern; otherwise throwing an exception with the specified message.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.matchesPattern(&quot;hi&quot;, &quot;[a-z]*&quot;, &quot;%s does not match %s&quot;, &quot;hi&quot; &quot;[a-z]*&quot;);&lt;/pre&gt;
     *
     * &lt;p&gt;The syntax of the pattern is the one used in the {@link Pattern} class.&lt;/p&gt;
     *
     * @param input  the character sequence to validate, not null
     * @param pattern  the regular expression pattern, not null
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @throws IllegalArgumentException if the character sequence does not match the pattern
     * @see #matchesPattern(CharSequence, String)
     *
     * @since 3.0
     */
    public static void matchesPattern(final CharSequence input, final String pattern, final String message, final Object... values) {
        // TODO when breaking BC, consider returning input
<span class="fc bfc" id="L874" title="All 2 branches covered.">        if (Pattern.matches(pattern, input) == false) {</span>
<span class="fc" id="L875">            throw new IllegalArgumentException(String.format(message, values));</span>
        }
<span class="fc" id="L877">    }</span>

    // inclusiveBetween
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validate that the specified argument object fall between the two
     * inclusive values specified; otherwise, throws an exception.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.inclusiveBetween(0, 2, 1);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the type of the argument object
     * @param start  the inclusive start value, not null
     * @param end  the inclusive end value, not null
     * @param value  the object to validate, not null
     * @throws IllegalArgumentException if the value falls outside the boundaries
     * @see #inclusiveBetween(Object, Object, Comparable, String, Object...)
     *
     * @since 3.0
     */
    public static &lt;T&gt; void inclusiveBetween(final T start, final T end, final Comparable&lt;T&gt; value) {
        // TODO when breaking BC, consider returning value
<span class="pc bpc" id="L899" title="1 of 4 branches missed.">        if (value.compareTo(start) &lt; 0 || value.compareTo(end) &gt; 0) {</span>
<span class="fc" id="L900">            throw new IllegalArgumentException(String.format(DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end));</span>
        }
<span class="fc" id="L902">    }</span>

    /**
     * &lt;p&gt;Validate that the specified argument object fall between the two
     * inclusive values specified; otherwise, throws an exception with the
     * specified message.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.inclusiveBetween(0, 2, 1, &quot;Not in boundaries&quot;);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the type of the argument object
     * @param start  the inclusive start value, not null
     * @param end  the inclusive end value, not null
     * @param value  the object to validate, not null
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @throws IllegalArgumentException if the value falls outside the boundaries
     * @see #inclusiveBetween(Object, Object, Comparable)
     *
     * @since 3.0
     */
    public static &lt;T&gt; void inclusiveBetween(final T start, final T end, final Comparable&lt;T&gt; value, final String message, final Object... values) {
        // TODO when breaking BC, consider returning value
<span class="pc bpc" id="L924" title="1 of 4 branches missed.">        if (value.compareTo(start) &lt; 0 || value.compareTo(end) &gt; 0) {</span>
<span class="fc" id="L925">            throw new IllegalArgumentException(String.format(message, values));</span>
        }
<span class="fc" id="L927">    }</span>

    // exclusiveBetween
    //---------------------------------------------------------------------------------

    /**
     * &lt;p&gt;Validate that the specified argument object fall between the two
     * exclusive values specified; otherwise, throws an exception.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.exclusiveBetween(0, 2, 1);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the type of the argument object
     * @param start  the exclusive start value, not null
     * @param end  the exclusive end value, not null
     * @param value  the object to validate, not null
     * @throws IllegalArgumentException if the value falls outside the boundaries
     * @see #exclusiveBetween(Object, Object, Comparable, String, Object...)
     *
     * @since 3.0
     */
    public static &lt;T&gt; void exclusiveBetween(final T start, final T end, final Comparable&lt;T&gt; value) {
        // TODO when breaking BC, consider returning value
<span class="pc bpc" id="L949" title="1 of 4 branches missed.">        if (value.compareTo(start) &lt;= 0 || value.compareTo(end) &gt;= 0) {</span>
<span class="fc" id="L950">            throw new IllegalArgumentException(String.format(DEFAULT_EXCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end));</span>
        }
<span class="fc" id="L952">    }</span>

    /**
     * &lt;p&gt;Validate that the specified argument object fall between the two
     * exclusive values specified; otherwise, throws an exception with the
     * specified message.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.exclusiveBetween(0, 2, 1, &quot;Not in boundaries&quot;);&lt;/pre&gt;
     *
     * @param &lt;T&gt; the type of the argument object
     * @param start  the exclusive start value, not null
     * @param end  the exclusive end value, not null
     * @param value  the object to validate, not null
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @throws IllegalArgumentException if the value falls outside the boundaries
     * @see #exclusiveBetween(Object, Object, Comparable)
     *
     * @since 3.0
     */
    public static &lt;T&gt; void exclusiveBetween(final T start, final T end, final Comparable&lt;T&gt; value, final String message, final Object... values) {
        // TODO when breaking BC, consider returning value
<span class="pc bpc" id="L974" title="1 of 4 branches missed.">        if (value.compareTo(start) &lt;= 0 || value.compareTo(end) &gt;= 0) {</span>
<span class="fc" id="L975">            throw new IllegalArgumentException(String.format(message, values));</span>
        }
<span class="fc" id="L977">    }</span>

    // isInstanceOf
    //---------------------------------------------------------------------------------

    /**
     * Validates that the argument is an instance of the specified class, if not throws an exception.
     *  
     * &lt;p&gt;This method is useful when validating according to an arbitrary class&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.isInstanceOf(OkClass.class, object);&lt;/pre&gt;
     *
     * &lt;p&gt;The message of the exception is &amp;quot;Expected type: {type}, actual: {obj_type}&amp;quot;&lt;/p&gt;
     *
     * @param type  the class the object must be validated against, not null
     * @param obj  the object to check, null throws an exception
     * @throws IllegalArgumentException if argument is not of specified class
     * @see #isInstanceOf(Class, Object, String, Object...)
     *
     * @since 3.0
     */
    public static void isInstanceOf(final Class&lt;?&gt; type, final Object obj) {
        // TODO when breaking BC, consider returning obj
<span class="fc bfc" id="L1000" title="All 2 branches covered.">        if (type.isInstance(obj) == false) {</span>
<span class="pc bpc" id="L1001" title="1 of 2 branches missed.">            throw new IllegalArgumentException(String.format(DEFAULT_IS_INSTANCE_OF_EX_MESSAGE, type.getName(),</span>
                    obj == null ? &quot;null&quot; : obj.getClass().getName()));
        }
<span class="fc" id="L1004">    }</span>

    /**
     * &lt;p&gt;Validate that the argument is an instance of the specified class; otherwise
     * throwing an exception with the specified message. This method is useful when
     * validating according to an arbitrary class&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.isInstanceOf(OkClass.classs, object, &quot;Wrong class, object is of class %s&quot;,
     *   object.getClass().getName());&lt;/pre&gt;
     *
     * @param type  the class the object must be validated against, not null
     * @param obj  the object to check, null throws an exception
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @throws IllegalArgumentException if argument is not of specified class
     * @see #isInstanceOf(Class, Object)
     *
     * @since 3.0
     */
    public static void isInstanceOf(final Class&lt;?&gt; type, final Object obj, final String message, final Object... values) {
        // TODO when breaking BC, consider returning obj
<span class="fc bfc" id="L1025" title="All 2 branches covered.">        if (type.isInstance(obj) == false) {</span>
<span class="fc" id="L1026">            throw new IllegalArgumentException(String.format(message, values));</span>
        }
<span class="fc" id="L1028">    }</span>

    // isAssignableFrom
    //---------------------------------------------------------------------------------

    /**
     * Validates that the argument can be converted to the specified class, if not, throws an exception.
     * 
     * &lt;p&gt;This method is useful when validating that there will be no casting errors.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.isAssignableFrom(SuperClass.class, object.getClass());&lt;/pre&gt;
     *
     * &lt;p&gt;The message format of the exception is &amp;quot;Cannot assign {type} to {superType}&amp;quot;&lt;/p&gt;
     *
     * @param superType  the class the class must be validated against, not null
     * @param type  the class to check, not null
     * @throws IllegalArgumentException if type argument is not assignable to the specified superType
     * @see #isAssignableFrom(Class, Class, String, Object...)
     *
     * @since 3.0
     */
    public static void isAssignableFrom(final Class&lt;?&gt; superType, final Class&lt;?&gt; type) {
        // TODO when breaking BC, consider returning type
<span class="fc bfc" id="L1051" title="All 2 branches covered.">        if (superType.isAssignableFrom(type) == false) {</span>
<span class="pc bpc" id="L1052" title="1 of 2 branches missed.">            throw new IllegalArgumentException(String.format(DEFAULT_IS_ASSIGNABLE_EX_MESSAGE, type == null ? &quot;null&quot; : type.getName(),</span>
                    superType.getName()));
        }
<span class="fc" id="L1055">    }</span>

    /**
     * Validates that the argument can be converted to the specified class, if not throws an exception.
     *  
     * &lt;p&gt;This method is useful when validating if there will be no casting errors.&lt;/p&gt;
     *
     * &lt;pre&gt;Validate.isAssignableFrom(SuperClass.class, object.getClass());&lt;/pre&gt;
     *
     * &lt;p&gt;The message of the exception is &amp;quot;The validated object can not be converted to the&amp;quot;
     * followed by the name of the class and &amp;quot;class&amp;quot;&lt;/p&gt;
     *
     * @param superType  the class the class must be validated against, not null
     * @param type  the class to check, not null
     * @param message  the {@link String#format(String, Object...)} exception message if invalid, not null
     * @param values  the optional values for the formatted exception message, null array not recommended
     * @throws IllegalArgumentException if argument can not be converted to the specified class
     * @see #isAssignableFrom(Class, Class)
     */
    public static void isAssignableFrom(final Class&lt;?&gt; superType, final Class&lt;?&gt; type, final String message, final Object... values) {
        // TODO when breaking BC, consider returning type
<span class="fc bfc" id="L1076" title="All 2 branches covered.">        if (superType.isAssignableFrom(type) == false) {</span>
<span class="fc" id="L1077">            throw new IllegalArgumentException(String.format(message, values));</span>
        }
<span class="fc" id="L1079">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.0.201403182114</span></div></body></html>