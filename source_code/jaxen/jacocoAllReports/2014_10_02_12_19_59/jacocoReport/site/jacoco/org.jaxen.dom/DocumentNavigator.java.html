<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DocumentNavigator.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jaxen</a> &gt; <a href="index.source.html" class="el_package">org.jaxen.dom</a> &gt; <span class="el_source">DocumentNavigator.java</span></div><h1>DocumentNavigator.java</h1><pre class="source lang-java linenums">package org.jaxen.dom;

/*
 * $Header$
 * $Revision: 1364 $
 * $Date: 2011-07-30 04:46:45 -0500 (Sat, 30 Jul 2011) $
 *
 * ====================================================================
 *
 * Copyright 2000-2005 bob mcwhirter &amp; James Strachan.
 * All rights reserved.
 *
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 * 
 *   * Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 
 *   * Neither the name of the Jaxen Project nor the names of its
 *     contributors may be used to endorse or promote products derived 
 *     from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS
 * IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
 * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Jaxen Project and was originally
 * created by bob mcwhirter &lt;bob@werken.com&gt; and
 * James Strachan &lt;jstrachan@apache.org&gt;.  For more information on the
 * Jaxen Project, please see &lt;http://www.jaxen.org/&gt;.
 *
 * $Id: DocumentNavigator.java 1364 2011-07-30 09:46:45Z elharo $
*/

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import java.io.IOException;
import java.util.HashMap;
import java.util.Iterator;
import java.util.NoSuchElementException;

import org.jaxen.DefaultNavigator;
import org.jaxen.FunctionCallException;
import org.jaxen.Navigator;
import org.jaxen.XPath;
import org.jaxen.JaxenConstants;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.ProcessingInstruction;
import org.xml.sax.SAXException;

/** Interface for navigating around the W3C DOM Level 2 object model.
 *
 *  &lt;p&gt;
 *  This class is not intended for direct usage, but is
 *  used by the Jaxen engine during evaluation.
 *  &lt;/p&gt;
 *
 *  &lt;p&gt;This class implements the {@link org.jaxen.DefaultNavigator} interface
 *  for the Jaxen XPath library.  This adapter allows the Jaxen
 *  library to be used to execute XPath queries against any object tree
 *  that implements the DOM level 2 interfaces.&lt;/p&gt;
 *
 *  &lt;p&gt;Note: DOM level 2 does not include a node representing an XPath
 *  namespace node.  This navigator will return namespace nodes
 *  as instances of the custom {@link NamespaceNode} class, and
 *  users will have to check result sets to locate and isolate
 *  these.&lt;/p&gt;
 *
 *  @author David Megginson
 *  @author James Strachan
 *
 *  @see XPath
 *  @see NamespaceNode
 */
public class DocumentNavigator extends DefaultNavigator
{

    
    ////////////////////////////////////////////////////////////////////
    // Constants.
    ////////////////////////////////////////////////////////////////////

    /**
     * 
     */
    private static final long serialVersionUID = 8460943068889528115L; 
    
<span class="fc" id="L110">    private final static DocumentNavigator SINGLETON = new DocumentNavigator();</span>


    
    ////////////////////////////////////////////////////////////////////
    // Constructor.
    ////////////////////////////////////////////////////////////////////


    /**
     * Default constructor.
     */
    public DocumentNavigator ()
<span class="fc" id="L123">    {</span>
<span class="fc" id="L124">    }</span>


    /**
     * Get a constant DocumentNavigator for efficiency.
     *
     * @return a constant instance of a DocumentNavigator.
     */
    public static Navigator getInstance ()
    {
<span class="fc" id="L134">        return SINGLETON;</span>
    }


    
    ////////////////////////////////////////////////////////////////////
    // Implementation of org.jaxen.DefaultNavigator.
    ////////////////////////////////////////////////////////////////////


    /**
     * Get an iterator over all of this node's children.
     *
     * @param contextNode the context node for the child axis.
     * @return a possibly-empty iterator (not null)
     */
    public Iterator getChildAxisIterator (Object contextNode)
    {
<span class="fc" id="L152">        Node node = (Node) contextNode;</span>

<span class="fc bfc" id="L154" title="All 4 branches covered.">        if ( node.getNodeType() == Node.ELEMENT_NODE || node.getNodeType() == Node.DOCUMENT_NODE)</span>
        {
<span class="fc" id="L156">            return new NodeIterator ((Node)contextNode) {</span>
                protected Node getFirstNode (Node node)
                {
<span class="fc" id="L159">                    return node.getFirstChild();</span>
                }
                protected Node getNextNode (Node node)
                {
<span class="fc" id="L163">                    return node.getNextSibling();</span>
                }
            };
        }

<span class="fc" id="L168">        return JaxenConstants.EMPTY_ITERATOR;</span>

    }


    /**
     * Get a (single-member) iterator over this node's parent.
     *
     * @param contextNode the context node for the parent axis
     * @return a possibly-empty iterator (not null)
     */
    public Iterator getParentAxisIterator (Object contextNode)
    {
<span class="fc" id="L181">        Node node = (Node)contextNode;</span>

<span class="fc bfc" id="L183" title="All 2 branches covered.">        if (node.getNodeType() == Node.ATTRIBUTE_NODE) {</span>
<span class="fc" id="L184">            return new NodeIterator (node) {</span>
                    protected Node getFirstNode (Node n)
                    {
                        // We can assume castability here because we've already
                        // tested the node type.
<span class="fc" id="L189">                        return ((Attr)n).getOwnerElement();</span>
                    }
                    protected Node getNextNode (Node n) {
<span class="fc" id="L192">                        return null;</span>
                    }
                };
        } else {
<span class="fc" id="L196">            return new NodeIterator (node) {</span>
                    protected Node getFirstNode (Node n)
                    {
<span class="fc" id="L199">                        return n.getParentNode();</span>
                    }
                    protected Node getNextNode (Node n) {
<span class="fc" id="L202">                        return null;</span>
                    }
                };
        }
    }
    
    
    /** 
     * Return the XPath parent of the supplied DOM node.
     * XPath has slightly different definition of parent than DOM does.
     * In particular, the parent of an attribute is not null.
     * 
     * @param child the child node
     * 
     * @return the parent of the specified node; or null if
     *     the node does not have a parent
     */
    public Object getParentNode(Object child) {
<span class="fc" id="L220">        Node node = (Node) child;</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">        if (node.getNodeType() == Node.ATTRIBUTE_NODE) {</span>
<span class="fc" id="L222">            return ((Attr) node).getOwnerElement();</span>
        }
<span class="fc" id="L224">        return node.getParentNode();</span>
    }


    /**
     * Get an iterator over all following siblings.
     *
     * @param contextNode the context node for the sibling iterator
     * @return a possibly-empty iterator (not null)
     */
    public Iterator getFollowingSiblingAxisIterator (Object contextNode)
    {
<span class="fc" id="L236">        return new NodeIterator ((Node)contextNode) {</span>
                protected Node getFirstNode (Node node)
                {
<span class="fc" id="L239">                    return getNextNode(node);</span>
                }
                protected Node getNextNode (Node node) {
<span class="fc" id="L242">                    return node.getNextSibling();</span>
                }
            };
    }


    /**
     * Get an iterator over all preceding siblings.
     *
     * @param contextNode the context node for the preceding sibling axis
     * @return a possibly-empty iterator (not null)
     */
    public Iterator getPrecedingSiblingAxisIterator (Object contextNode)
    {
<span class="fc" id="L256">        return new NodeIterator ((Node)contextNode) {</span>
                protected Node getFirstNode (Node node)
                {
<span class="fc" id="L259">                    return getNextNode(node);</span>
                }
                protected Node getNextNode (Node node) {
<span class="fc" id="L262">                    return node.getPreviousSibling();</span>
                }
            };
    }


    /**
     * Get an iterator over all following nodes, depth-first.
     *
     * @param contextNode the context node for the following axis
     * @return a possibly-empty iterator (not null)
     */
    public Iterator getFollowingAxisIterator (Object contextNode)
    {
<span class="fc" id="L276">        return new NodeIterator ((Node)contextNode) {</span>
                protected Node getFirstNode (Node node)
                {
<span class="fc bfc" id="L279" title="All 2 branches covered.">                    if (node == null) {</span>
<span class="fc" id="L280">                        return null;</span>
                    }
                    else {
<span class="fc" id="L283">                        Node sibling = node.getNextSibling();</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">                        if (sibling == null) {</span>
<span class="fc" id="L285">                            return getFirstNode(node.getParentNode());</span>
                        }
                        else {
<span class="fc" id="L288">                            return sibling;</span>
                        }
                    }
                }
                protected Node getNextNode (Node node) {
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">                    if (node == null) {</span>
<span class="nc" id="L294">                        return null;</span>
                    }
                    else {
<span class="fc" id="L297">                        Node n = node.getFirstChild();</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">                        if (n == null) n = node.getNextSibling();</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">                        if (n == null) return getFirstNode(node.getParentNode());</span>
<span class="fc" id="L300">                        else return n;</span>
                    }
                }
            };
    }


    /**
     * Get an iterator over all attributes.
     *
     * @param contextNode the context node for the attribute axis
     * @return a possibly-empty iterator (not null)
     */
    public Iterator getAttributeAxisIterator (Object contextNode)
    {
<span class="fc bfc" id="L315" title="All 2 branches covered.">        if (isElement(contextNode)) {</span>
<span class="fc" id="L316">            return new AttributeIterator((Node)contextNode);</span>
        } 
        else {
<span class="fc" id="L319">            return JaxenConstants.EMPTY_ITERATOR;</span>
        }
    }


    /**
     * Get an iterator over all declared namespaces.
     *
     * &lt;p&gt;Note: this iterator is not live: it takes a snapshot
     * and that snapshot remains static during the life of
     * the iterator (i.e. it won't reflect subsequent changes
     * to the DOM).&lt;/p&gt;
     * 
     * &lt;p&gt;
     * In the event that the DOM is inconsistent; for instance a 
     * &lt;code&gt;pre:foo&lt;/code&gt; element is declared by DOM to be in the 
     * http://www.a.com/ namespace but also has an 
     * &lt;code&gt;xmlns:pre=&quot;http://www.b.com&quot;&lt;/code&gt; attribute; then only 
     * one of the namespaces will be counted. This will be the intrinsic
     * namespace of the &lt;code&gt;Element&lt;/code&gt; or &lt;code&gt;Attr&lt;/code&gt; object
     * rather than the one provide by the contradictory namespace 
     * declaration attribute. In the event of a contradiction between two
     * attributes on the same element--e.g. &lt;code&gt;pre:foo&lt;/code&gt; in the
     * http://www.a.com/ namespace and &lt;code&gt;pre:bar&lt;/code&gt; in the 
     * http://www.b.com/ namespace--it is undefined which namespace
     * will be returned. 
     * &lt;/p&gt;
     *
     * @param contextNode the context node for the namespace axis
     * @return a possibly-empty iterator (not null)
     */
    public Iterator getNamespaceAxisIterator (Object contextNode)
    {
        // Only elements have namespace nodes
<span class="fc bfc" id="L353" title="All 2 branches covered.">        if (isElement(contextNode)) {</span>

<span class="fc" id="L355">            HashMap nsMap = new HashMap();</span>

            // Starting at the current node, walk
            // up to the root, noting the namespace
            // declarations in scope.
<span class="fc" id="L360">            for (Node n = (Node) contextNode;</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">                 n != null;</span>
<span class="fc" id="L362">                 n = n.getParentNode()) {</span>
                
                // 1. Look for the namespace of the element itself
<span class="fc" id="L365">                String myNamespace = n.getNamespaceURI();</span>
<span class="pc bpc" id="L366" title="1 of 4 branches missed.">                if (myNamespace != null &amp;&amp; ! &quot;&quot;.equals(myNamespace)) {</span>
<span class="fc" id="L367">                    String myPrefix = n.getPrefix();</span>
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">                    if (!nsMap.containsKey(myPrefix)) {</span>
<span class="fc" id="L369">                        NamespaceNode ns = new NamespaceNode((Node) contextNode, myPrefix, myNamespace);</span>
<span class="fc" id="L370">                        nsMap.put(myPrefix, ns);</span>
                    }
                }

<span class="fc bfc" id="L374" title="All 2 branches covered.">                if (n.hasAttributes()) {</span>
<span class="fc" id="L375">                    NamedNodeMap atts = n.getAttributes();</span>
<span class="fc" id="L376">                    int length = atts.getLength();</span>
                    // 2. Look for namespaces of attributes
<span class="fc bfc" id="L378" title="All 2 branches covered.">                    for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L379">                        Attr att = (Attr) atts.item(i);</span>
                        // Work around Crimson bug by testing URI rather than name
<span class="fc" id="L381">                        String attributeNamespace = att.getNamespaceURI();</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">                        if (&quot;http://www.w3.org/2000/xmlns/&quot;.equals(attributeNamespace)) {</span>
                        }
<span class="fc bfc" id="L384" title="All 2 branches covered.">                        else if (attributeNamespace != null) {</span>
<span class="fc" id="L385">                            String prefix = att.getPrefix();</span>
<span class="fc" id="L386">                            NamespaceNode ns =</span>
                                new NamespaceNode((Node)contextNode, prefix, attributeNamespace);
                            // Add only if there's not a closer declaration in force.
<span class="fc bfc" id="L389" title="All 2 branches covered.">                            if (!nsMap.containsKey(prefix)) nsMap.put(prefix, ns);</span>
                            
                        }
                    }
                    
                    // 3. Look for namespace declaration attributes
<span class="fc bfc" id="L395" title="All 2 branches covered.">                    for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L396">                        Attr att = (Attr) atts.item(i);</span>
                        // work around crimson bug by testing URI rather than name
<span class="fc" id="L398">                        String attributeNamespace = att.getNamespaceURI();</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">                        if (&quot;http://www.w3.org/2000/xmlns/&quot;.equals(attributeNamespace)) {</span>
<span class="fc" id="L400">                            NamespaceNode ns =</span>
                              new NamespaceNode( (Node)contextNode, att);
                            // Add only if there's not a closer declaration in force.
<span class="fc" id="L403">                            String name = ns.getNodeName();</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">                            if (!nsMap.containsKey(name)) nsMap.put(name, ns);</span>
                        }
                    }
                    
                }
                
            }
            // Section 5.4 of the XPath rec requires
            // this to be present.
<span class="fc" id="L413">            nsMap.put(&quot;xml&quot;,</span>
                      new
                      NamespaceNode((Node)contextNode,
                                    &quot;xml&quot;,
                                    &quot;http://www.w3.org/XML/1998/namespace&quot;));

            // An empty default namespace cancels
            // any previous default.
<span class="fc" id="L421">            NamespaceNode defaultNS = (NamespaceNode)nsMap.get(&quot;&quot;);</span>
<span class="pc bpc" id="L422" title="3 of 4 branches missed.">            if (defaultNS != null &amp;&amp; defaultNS.getNodeValue().length() == 0) {</span>
<span class="nc" id="L423">                nsMap.remove(&quot;&quot;);</span>
            }
<span class="fc" id="L425">            return nsMap.values().iterator();</span>
        } 
        else {
<span class="fc" id="L428">            return JaxenConstants.EMPTY_ITERATOR;</span>
        }
    }

    /** Returns a parsed form of the given XPath string, which will be suitable
     *  for queries on DOM documents.
     *  
     * @param xpath the XPath expression
     * @return a parsed form of the given XPath string
     * @throws org.jaxen.saxpath.SAXPathException if the string is syntactically incorrect
     */
    public XPath parseXPath (String xpath) throws org.jaxen.saxpath.SAXPathException
    {
<span class="fc" id="L441">        return new DOMXPath(xpath);</span>
    }

    /**
     * Get the top-level document node.
     *
     * @param contextNode any node in the document
     * @return the root node
     */
    public Object getDocumentNode (Object contextNode)
    {
<span class="fc bfc" id="L452" title="All 2 branches covered.">        if (isDocument(contextNode)) return contextNode;</span>
<span class="fc" id="L453">        else return ((Node)contextNode).getOwnerDocument();</span>
    }

    // Why are there separate methods for getElementNamespaceURI and 
    // getAttributeNamespaceURI when they do exactly the same thing?
    // This should be combined in a future version.
    /**
     * Get the namespace URI of an element.
     *
     * @param element the target node
     * @return a string (possibly empty) if the node is an element,
     * and null otherwise
     */
    public String getElementNamespaceUri (Object element)
    {
        try {
<span class="fc" id="L469">            Node node = (Node) element;</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">            if (node.getNodeType() == Node.ELEMENT_NODE) {</span>
<span class="fc" id="L471">                return node.getNamespaceURI();</span>
            }
        }
<span class="nc" id="L474">        catch (ClassCastException ex) {</span>
<span class="fc" id="L475">        }</span>
<span class="fc" id="L476">        return null;</span>
    }


    /**
     * Get the local name of an element.
     *
     * @param element the target node
     * @return a string representing the unqualified local name
     *     if the node is an element, or null otherwise
     */
    public String getElementName (Object element)
    {
<span class="fc bfc" id="L489" title="All 2 branches covered.">        if (isElement(element)) {</span>
<span class="fc" id="L490">            String name = ((Node)element).getLocalName();</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">            if (name == null) name = ((Node)element).getNodeName();</span>
<span class="fc" id="L492">            return name;</span>
        }
<span class="fc" id="L494">        return null;</span>
    }


    /**
     * Get the qualified name of an element.
     *
     * @param element the target node
     * @return a string representing the qualified (i.e. possibly
     *   prefixed) name if the argument is an element, or null otherwise
     */
    public String getElementQName (Object element)
    {
        try {
<span class="fc" id="L508">            Node node = (Node) element;</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">            if (node.getNodeType() == Node.ELEMENT_NODE) {</span>
<span class="fc" id="L510">                return node.getNodeName();</span>
            }
        }
<span class="nc" id="L513">        catch (ClassCastException ex) {</span>
<span class="fc" id="L514">        }</span>
<span class="fc" id="L515">        return null;</span>
    }


    /**
     * Get the namespace URI of an attribute.
     *
     * @param attribute the target node
     * 
     * @return the namespace name of the specified node
     * 
     */
    public String getAttributeNamespaceUri (Object attribute)
    {
        try {
<span class="fc" id="L530">            Node node = (Node) attribute;</span>
<span class="fc bfc" id="L531" title="All 2 branches covered.">            if (node.getNodeType() == Node.ATTRIBUTE_NODE) {</span>
<span class="fc" id="L532">                return node.getNamespaceURI();</span>
            }
        }
<span class="nc" id="L535">        catch (ClassCastException ex) {</span>
<span class="fc" id="L536">        }</span>
<span class="fc" id="L537">        return null;</span>
    }


    /**
     * Get the local name of an attribute.
     *
     * @param attribute the target node
     * @return a string representing the unqualified local name
     * if the node is an attribute, or null otherwise
     */
    public String getAttributeName (Object attribute)
    {
<span class="fc bfc" id="L550" title="All 2 branches covered.">        if (isAttribute(attribute)) {</span>
<span class="fc" id="L551">            String name = ((Node)attribute).getLocalName();</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">            if (name == null) name = ((Node)attribute).getNodeName();</span>
<span class="fc" id="L553">            return name;</span>
        }
<span class="fc" id="L555">        return null;</span>
    }


    /**
     * Get the qualified name of an attribute.
     *
     * @param attribute the target node
     * 
     * @return a string representing the qualified (i.e. possibly
     * prefixed) name if the argument is an attribute, or null otherwise
     */
    public String getAttributeQName (Object attribute)
    {
        try {
<span class="fc" id="L570">            Node node = (Node) attribute;</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">            if (node.getNodeType() == Node.ATTRIBUTE_NODE) {</span>
<span class="fc" id="L572">                return node.getNodeName();</span>
            }
        }
<span class="nc" id="L575">        catch (ClassCastException ex) {</span>
<span class="fc" id="L576">        }</span>
<span class="fc" id="L577">        return null;</span>
    }


    /**
     * Test if a node is a top-level document.
     *
     * @param object the target node
     * @return true if the node is the document root, false otherwise
     */
    public boolean isDocument (Object object)
    {
<span class="fc bfc" id="L589" title="All 4 branches covered.">        return (object instanceof Node) &amp;&amp;</span>
            (((Node)object).getNodeType() == Node.DOCUMENT_NODE);
    }


    /**
     * Test if a node is a namespace.
     *
     * @param object the target node
     * @return true if the node is a namespace, false otherwise
     */
    public boolean isNamespace (Object object)
    {
<span class="fc" id="L602">        return (object instanceof NamespaceNode);</span>
    }


    /**
     * Test if a node is an element.
     *
     * @param object the target node
     * @return true if the node is an element, false otherwise
     */
    public boolean isElement (Object object)
    {
<span class="fc bfc" id="L614" title="All 4 branches covered.">        return (object instanceof Node) &amp;&amp;</span>
            (((Node)object).getNodeType() == Node.ELEMENT_NODE);
    }


    /**
     * Test if a node is an attribute. &lt;code&gt;xmlns&lt;/code&gt; and 
     * &lt;code&gt;xmlns:pre&lt;/code&gt; attributes do not count as attributes
     * for the purposes of XPath. 
     *
     * @param object the target node
     * @return true if the node is an attribute, false otherwise
     */
    public boolean isAttribute (Object object)
    {
<span class="pc bpc" id="L629" title="1 of 6 branches missed.">        return (object instanceof Node) &amp;&amp;</span>
            (((Node)object).getNodeType() == Node.ATTRIBUTE_NODE)
            &amp;&amp; ! &quot;http://www.w3.org/2000/xmlns/&quot;.equals(((Node) object).getNamespaceURI());
    }


    /**
     * Test if a node is a comment.
     *
     * @param object the target node
     * @return true if the node is a comment, false otherwise
     */
    public boolean isComment (Object object)
    {
<span class="fc bfc" id="L643" title="All 4 branches covered.">        return (object instanceof Node) &amp;&amp;</span>
            (((Node)object).getNodeType() == Node.COMMENT_NODE);
    }


    /**
     * Test if a node is plain text.
     *
     * @param object the target node
     * @return true if the node is a text node, false otherwise
     */
    public boolean isText (Object object)
    {
<span class="fc bfc" id="L656" title="All 2 branches covered.">        if (object instanceof Node) {</span>
<span class="fc bfc" id="L657" title="All 2 branches covered.">            switch (((Node)object).getNodeType()) {</span>
                case Node.TEXT_NODE:
                case Node.CDATA_SECTION_NODE:
<span class="fc" id="L660">                    return true;</span>
                default:
<span class="fc" id="L662">                    return false;</span>
            }
        } else {
<span class="fc" id="L665">            return false;</span>
        }
    }


    /**
     * Test if a node is a processing instruction.
     *
     * @param object the target node
     * @return true if the node is a processing instruction, false otherwise
     */
    public boolean isProcessingInstruction (Object object)
    {
<span class="fc bfc" id="L678" title="All 4 branches covered.">        return (object instanceof Node) &amp;&amp;</span>
            (((Node)object).getNodeType() == Node.PROCESSING_INSTRUCTION_NODE);
    }


    /**
     * Get the string value of an element node.
     *
     * @param object the target node
     * @return the text inside the node and its descendants if the node
     * is an element, null otherwise
     */
    public String getElementStringValue (Object object)
    {
<span class="pc bpc" id="L692" title="1 of 2 branches missed.">        if (isElement(object)) {</span>
<span class="fc" id="L693">            return getStringValue((Node)object, new StringBuffer()).toString();</span>
        }
        else {
<span class="nc" id="L696">            return null;</span>
        }
    }


    /**
     * Construct a node's string value recursively.
     *
     * @param node the current node
     * @param buffer the buffer for building the text
     * @return the buffer passed as a parameter (for convenience)
     */
    private StringBuffer getStringValue (Node node, StringBuffer buffer)
    {
<span class="fc bfc" id="L710" title="All 2 branches covered.">        if (isText(node)) {</span>
<span class="fc" id="L711">            buffer.append(node.getNodeValue());</span>
        } else {
<span class="fc" id="L713">            NodeList children = node.getChildNodes();</span>
<span class="fc" id="L714">            int length = children.getLength();</span>
<span class="fc bfc" id="L715" title="All 2 branches covered.">            for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L716">                getStringValue(children.item(i), buffer);</span>
            }
        }
<span class="fc" id="L719">        return buffer;</span>
    }


    /**
     * Get the string value of an attribute node.
     *
     * @param object the target node
     * @return the text of the attribute value if the node is an
     *     attribute, null otherwise
     */
    public String getAttributeStringValue (Object object)
    {
<span class="pc bpc" id="L732" title="1 of 2 branches missed.">        if (isAttribute(object)) return ((Node)object).getNodeValue();</span>
<span class="nc" id="L733">        else return null;</span>
    }


    /**
     * Get the string value of text.
     *
     * @param object the target node
     * @return the string of text if the node is text, null otherwise
     */
    public String getTextStringValue (Object object)
    {
<span class="pc bpc" id="L745" title="1 of 2 branches missed.">        if (isText(object)) return ((Node)object).getNodeValue();</span>
<span class="nc" id="L746">        else return null;</span>
    }


    /**
     * Get the string value of a comment node.
     *
     * @param object the target node
     * @return the text of the comment if the node is a comment, null otherwise
     */
    public String getCommentStringValue (Object object)
    {
<span class="pc bpc" id="L758" title="1 of 2 branches missed.">        if (isComment(object)) return ((Node)object).getNodeValue();</span>
<span class="nc" id="L759">        else return null;</span>
    }


    /**
     * Get the string value of a namespace node.
     *
     * @param object the target node
     * @return the namespace URI as a (possibly empty) string if the
     *     node is a namespace node, null otherwise
     */
    public String getNamespaceStringValue (Object object)
    {
<span class="pc bpc" id="L772" title="1 of 2 branches missed.">        if (isNamespace(object)) return ((NamespaceNode)object).getNodeValue();</span>
<span class="nc" id="L773">        else return null;</span>
    }

    /**
     * Get the prefix value of a namespace node.
     *
     * @param object the target node
     * @return the namespace prefix a (possibly empty) string if the
     *     node is a namespace node, null otherwise
     */
    public String getNamespacePrefix (Object object)
    {
<span class="pc bpc" id="L785" title="1 of 2 branches missed.">        if (isNamespace(object)) return ((NamespaceNode)object).getLocalName();</span>
<span class="nc" id="L786">        else return null;</span>
    }

    /**
     * Translate a namespace prefix to a URI.
     * 
     * @param prefix the namespace prefix
     * @param element the namespace context
     * @return the namespace URI bound to the prefix in the scope of &lt;code&gt;element&lt;/code&gt;;
     *     null if the prefix is not bound
     */
    public String translateNamespacePrefixToUri (String prefix, Object element)
    {
<span class="nc" id="L799">        Iterator it = getNamespaceAxisIterator(element);</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L801">            NamespaceNode ns = (NamespaceNode)it.next();</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">            if (prefix.equals(ns.getNodeName())) return ns.getNodeValue();</span>
<span class="nc" id="L803">        }</span>
<span class="nc" id="L804">        return null;</span>
    }

    /**
     * Use JAXP to load a namespace aware document from a given URI.
     *
     * @param uri the URI of the document to load
     * @return the new W3C DOM Level 2 Document instance
     * @throws FunctionCallException containing a nested exception
     *      if a problem occurs trying to parse the given document
     *
     * @todo Possibly we could make the factory a thread local.
     */
    public Object getDocument(String uri) throws FunctionCallException
    {
        try
        {
            // We really do need to construct a new factory here each time.
            // DocumentBuilderFactory is not guaranteed to be thread safe? 
<span class="fc" id="L823">            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span>
<span class="fc" id="L824">            factory.setNamespaceAware(true);</span>
<span class="fc" id="L825">            DocumentBuilder builder = factory.newDocumentBuilder();</span>
<span class="fc" id="L826">            return builder.parse( uri );</span>
        }
<span class="nc" id="L828">        catch (ParserConfigurationException e) {</span>
<span class="nc" id="L829">            throw new FunctionCallException(&quot;JAXP setup error in document() function: &quot; + e.getMessage(), e);</span>
        }
<span class="nc" id="L831">        catch (SAXException e) {</span>
<span class="nc" id="L832">           throw new FunctionCallException(&quot;XML error in document() function: &quot; + e.getMessage(), e);</span>
        }
<span class="nc" id="L834">        catch (IOException e) {</span>
<span class="nc" id="L835">           throw new FunctionCallException(&quot;I/O error in document() function: &quot; + e.getMessage(), e);</span>
        }
        
    }
    
    /**
     * Get the target of a processing instruction node.
     * 
     * @param obj the processing instruction
     * @return the target of the processing instruction
     * @throws ClassCastException if obj is not a processing instruction
     * 
     */
    public String getProcessingInstructionTarget(Object obj)
    {      
<span class="fc bfc" id="L850" title="All 2 branches covered.">        if (isProcessingInstruction(obj)) {</span>
<span class="fc" id="L851">            ProcessingInstruction pi = (ProcessingInstruction) obj;</span>
<span class="fc" id="L852">            return pi.getTarget();</span>
        }
<span class="fc" id="L854">        throw new ClassCastException(obj + &quot; is not a processing instruction&quot;);</span>
    }

    /**
     * Get the data of a processing instruction node.
     * 
     * @param obj the processing instruction
     * @return the target of the processing instruction
     * @throws ClassCastException if obj is not a processing instruction
     * 
     */
    public String getProcessingInstructionData(Object obj)
    {
<span class="fc bfc" id="L867" title="All 2 branches covered.">        if (isProcessingInstruction(obj)) {</span>
<span class="fc" id="L868">            ProcessingInstruction pi = (ProcessingInstruction) obj;</span>
<span class="fc" id="L869">            return pi.getData();</span>
        }
<span class="fc" id="L871">        throw new ClassCastException(obj + &quot; is not a processing instruction&quot;);</span>
    }

    
    ////////////////////////////////////////////////////////////////////
    // Inner class: iterate over DOM nodes.
    ////////////////////////////////////////////////////////////////////


    // FIXME: needs to recurse into
    // DocumentFragment and EntityReference
    // to use their children.

    /**
     * A generic iterator over DOM nodes.
     *
     * &lt;p&gt;Concrete subclasses must implement the {@link #getFirstNode}
     * and {@link #getNextNode} methods for a specific iteration
     * strategy.&lt;/p&gt;
     */
    abstract class NodeIterator
    implements Iterator
    {


        /**
         * Constructor.
         *
         * @param contextNode the starting node
         */
        public NodeIterator (Node contextNode)
<span class="fc" id="L902">        {</span>
<span class="fc" id="L903">            node = getFirstNode(contextNode);</span>
<span class="fc bfc" id="L904" title="All 2 branches covered.">            while (!isXPathNode(node)) {</span>
<span class="fc" id="L905">                node = getNextNode(node);</span>
            }
<span class="fc" id="L907">        }</span>

        public boolean hasNext ()
        {
<span class="fc bfc" id="L911" title="All 2 branches covered.">            return (node != null);</span>
        }

        public Object next ()
        {
<span class="pc bpc" id="L916" title="1 of 2 branches missed.">            if (node == null) throw new NoSuchElementException();</span>
<span class="fc" id="L917">            Node ret = node;</span>
<span class="fc" id="L918">            node = getNextNode(node);</span>
<span class="pc bpc" id="L919" title="1 of 2 branches missed.">            while (!isXPathNode(node)) {</span>
<span class="nc" id="L920">                node = getNextNode(node);</span>
            }
<span class="fc" id="L922">            return ret;</span>
        }

        public void remove ()
        {
<span class="nc" id="L927">            throw new UnsupportedOperationException();</span>
        }


        /**
         * Get the first node for iteration.
         *
         * &lt;p&gt;This method must derive an initial node for iteration
         * from a context node.&lt;/p&gt;
         *
         * @param contextNode the starting node
         * @return the first node in the iteration
         * @see #getNextNode
         */
        protected abstract Node getFirstNode (Node contextNode);


        /**
         * Get the next node for iteration.
         *
         * &lt;p&gt;This method must locate a following node from the
         * current context node.&lt;/p&gt;
         *
         * @param contextNode the current node in the iteration
         * @return the following node in the iteration, or null
         * if there is none
         * @see #getFirstNode
         */
        protected abstract Node getNextNode (Node contextNode);


        /**
         * Test whether a DOM node is usable by XPath.
         *
         * @param node the DOM node to test
         * @return true if the node is usable, false if it should be skipped
         */
        private boolean isXPathNode (Node node)
        {
            // null is usable, because it means end
<span class="fc bfc" id="L967" title="All 2 branches covered.">            if (node == null) return true;</span>

<span class="fc bfc" id="L969" title="All 2 branches covered.">            switch (node.getNodeType()) {</span>
                case Node.DOCUMENT_FRAGMENT_NODE:
                case Node.DOCUMENT_TYPE_NODE:
                case Node.ENTITY_NODE:
                case Node.ENTITY_REFERENCE_NODE:
                case Node.NOTATION_NODE:
<span class="fc" id="L975">                    return false;</span>
                default:
<span class="fc" id="L977">                    return true;</span>
            }
        }

        private Node node;
    }


    
    ////////////////////////////////////////////////////////////////////
    // Inner class: iterate over a DOM named node map.
    ////////////////////////////////////////////////////////////////////


    /**
     * An iterator over an attribute list.
     */
    private static class AttributeIterator implements Iterator
    {

        /**
         * Constructor.
         *
         * @param parent the parent DOM element for the attributes.
         */
        AttributeIterator (Node parent)
<span class="fc" id="L1003">        {</span>
<span class="fc" id="L1004">            this.map = parent.getAttributes();</span>
<span class="fc" id="L1005">            this.pos = 0;</span>
<span class="fc bfc" id="L1006" title="All 2 branches covered.">            for (int i = this.map.getLength()-1; i &gt;= 0; i--) {</span>
<span class="fc" id="L1007">                Node node = map.item(i);</span>
<span class="fc bfc" id="L1008" title="All 2 branches covered.">                if (! &quot;http://www.w3.org/2000/xmlns/&quot;.equals(node.getNamespaceURI())) {</span>
<span class="fc" id="L1009">                    this.lastAttribute  = i;</span>
<span class="fc" id="L1010">                    break;</span>
                }
            }
<span class="fc" id="L1013">        }</span>

        public boolean hasNext ()
        {
<span class="fc bfc" id="L1017" title="All 2 branches covered.">            return pos &lt;= lastAttribute;</span>
        }

        public Object next ()
        {
<span class="fc" id="L1022">            Node attr = map.item(pos++);</span>
<span class="pc bpc" id="L1023" title="1 of 2 branches missed.">            if (attr == null) throw new NoSuchElementException();</span>
<span class="pc bpc" id="L1024" title="1 of 2 branches missed.">            else if (&quot;http://www.w3.org/2000/xmlns/&quot;.equals(attr.getNamespaceURI())) {</span>
              // XPath doesn't consider namespace declarations to be attributes 
              // so skip it and go to the next one
<span class="nc" id="L1027">              return next();</span>
            }
<span class="fc" id="L1029">            else return attr;</span>
        }

        public void remove ()
        {
<span class="nc" id="L1034">            throw new UnsupportedOperationException();</span>
        }


        private NamedNodeMap map;
        private int pos;
<span class="fc" id="L1040">        private int lastAttribute = -1;</span>

    }

    /**
     *  Returns the element whose ID is given by elementId.
     *  If no such element exists, returns null.
     *  Attributes with the name &quot;ID&quot; are not of type ID unless so defined.
     *  Attribute types are only known if when the parser understands DTD's or
     *  schemas that declare attributes of type ID. When JAXP is used, you
     *  must call &lt;code&gt;setValidating(true)&lt;/code&gt; on the
     *  DocumentBuilderFactory.
     *
     *  @param object   a node from the document in which to look for the id
     *  @param elementId   id to look for
     *
     *  @return   element whose ID is given by elementId, or null if no such
     *            element exists in the document or if the implementation
     *            does not know about attribute types
     *  @see   javax.xml.parsers.DocumentBuilderFactory
     *  
     *  @throws ClassCastException if object is not an &lt;code&gt;org.w3c.dom.Node&lt;/code&gt; object
     *  
     */
    public Object getElementById(Object object, String elementId)
    {
<span class="fc" id="L1066">        Document doc = (Document)getDocumentNode(object);</span>
<span class="pc bpc" id="L1067" title="1 of 2 branches missed.">        if (doc != null) return doc.getElementById(elementId);</span>
<span class="nc" id="L1068">        else return null;</span>
    }

}

// end of DocumentNavigator.java
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.0.201403182114</span></div></body></html>