<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JDOMResult.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jdom</a> &gt; <a href="index.source.html" class="el_package">org.jdom2.transform</a> &gt; <span class="el_source">JDOMResult.java</span></div><h1>JDOMResult.java</h1><pre class="source lang-java linenums">/*-- 

 Copyright (C) 2001-2007 Jason Hunter &amp; Brett McLaughlin.
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:

 1. Redistributions of source code must retain the above copyright
    notice, this list of conditions, and the following disclaimer.

 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions, and the disclaimer that follows 
    these conditions in the documentation and/or other materials 
    provided with the distribution.

 3. The name &quot;JDOM&quot; must not be used to endorse or promote products
    derived from this software without prior written permission.  For
    written permission, please contact &lt;request_AT_jdom_DOT_org&gt;.

 4. Products derived from this software may not be called &quot;JDOM&quot;, nor
    may &quot;JDOM&quot; appear in their name, without prior written permission
    from the JDOM Project Management &lt;request_AT_jdom_DOT_org&gt;.

 In addition, we request (but do not require) that you include in the 
 end-user documentation provided with the redistribution and/or in the 
 software itself an acknowledgement equivalent to the following:
     &quot;This product includes software developed by the
      JDOM Project (http://www.jdom.org/).&quot;
 Alternatively, the acknowledgment may be graphical using the logos 
 available at http://www.jdom.org/images/logos.

 THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED.  IN NO EVENT SHALL THE JDOM AUTHORS OR THE PROJECT
 CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 SUCH DAMAGE.

 This software consists of voluntary contributions made by many 
 individuals on behalf of the JDOM Project and was originally 
 created by Jason Hunter &lt;jhunter_AT_jdom_DOT_org&gt; and
 Brett McLaughlin &lt;brett_AT_jdom_DOT_org&gt;.  For more information
 on the JDOM Project, please see &lt;http://www.jdom.org/&gt;.

 */

package org.jdom2.transform;

import java.util.*;

import javax.xml.transform.sax.*;

import org.jdom2.*;
import org.jdom2.input.sax.SAXHandler;

import org.xml.sax.*;
import org.xml.sax.ext.*;
import org.xml.sax.helpers.*;

/**
 * A holder for an XSL Transformation result, generally a list of nodes
 * although it can be a JDOM Document also. As stated by the XSLT 1.0
 * specification, the result tree generated by an XSL transformation is not
 * required to be a well-formed XML document. The result tree may have &quot;any
 * sequence of nodes as children that would be possible for an
 * element node&quot;.
 * &lt;p&gt;
 * The following example shows how to apply an XSL Transformation
 * to a JDOM document and get the transformation result in the form
 * of a list of JDOM nodes:
 * &lt;pre&gt;&lt;code&gt;
 *   public static List transform(Document doc, String stylesheet)
 *                                        throws JDOMException {
 *     try {
 *       Transformer transformer = TransformerFactory.newInstance()
 *                             .newTransformer(new StreamSource(stylesheet));
 *       JDOMSource in = new JDOMSource(doc);
 *       JDOMResult out = new JDOMResult();
 *       transformer.transform(in, out);
 *       return out.getResult();
 *     }
 *     catch (TransformerException e) {
 *       throw new JDOMException(&quot;XSLT Transformation failed&quot;, e);
 *     }
 *   }
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * @see      org.jdom2.transform.JDOMSource
 *
 * @author  Laurent Bihanic
 * @author  Jason Hunter
 */
public class JDOMResult extends SAXResult {

	/**
	 * If {@link javax.xml.transform.TransformerFactory#getFeature}
	 * returns &lt;code&gt;true&lt;/code&gt; when passed this value as an
	 * argument, the Transformer natively supports JDOM.
	 * &lt;p&gt;
	 * &lt;strong&gt;Note&lt;/strong&gt;: This implementation does not override
	 * the {@link SAXResult#FEATURE} value defined by its superclass
	 * to be considered as a SAXResult by Transformer implementations
	 * not natively supporting JDOM.&lt;/p&gt;
	 */
	public final static String JDOM_FEATURE =
			JDOMConstants.JDOM2_FEATURE_JDOMRESULT;

	/**
	 * The result of a transformation, as set by Transformer
	 * implementations that natively support JDOM, as a JDOM document
	 * or a list of JDOM nodes.
	 */
<span class="fc" id="L121">	private List&lt;Content&gt; resultlist = null;</span>

<span class="fc" id="L123">	private Document resultdoc = null;</span>

	/**
	 * Whether the application queried the result (as a list or a
	 * document) since it was last set.
	 */
<span class="fc" id="L129">	private boolean queried = false;</span>

	/**
	 * The custom JDOM factory to use when building the transformation
	 * result or &lt;code&gt;null&lt;/code&gt; to use the default JDOM classes.
	 */
<span class="fc" id="L135">	private JDOMFactory factory = null;</span>

	/**
	 * Public default constructor.
	 */
<span class="fc" id="L140">	public JDOMResult() {</span>
		// Allocate custom builder object...
<span class="fc" id="L142">		DocumentBuilder builder = new DocumentBuilder();</span>

		// And use it as ContentHandler and LexicalHandler.
<span class="fc" id="L145">		super.setHandler(builder);</span>
<span class="fc" id="L146">		super.setLexicalHandler(builder);</span>
<span class="fc" id="L147">	}</span>

	/**
	 * Sets the object(s) produced as result of an XSL Transformation.
	 * &lt;p&gt;
	 * &lt;strong&gt;Note&lt;/strong&gt;: This method shall be used by the
	 * {@link javax.xml.transform.Transformer} implementations that
	 * natively support JDOM to directly set the transformation
	 * result rather than considering this object as a
	 * {@link SAXResult}.  Applications should &lt;i&gt;not&lt;/i&gt; use this
	 * method.&lt;/p&gt;
	 *
	 * @param  result   the result of a transformation as a
	 *                  {@link java.util.List list} of JDOM nodes
	 *                  (Elements, Texts, Comments, PIs...).
	 *
	 * @see    #getResult
	 */
	public void setResult(List&lt;Content&gt; result) {
<span class="fc" id="L166">		this.resultlist  = result;</span>
<span class="fc" id="L167">		this.queried = false;</span>
<span class="fc" id="L168">	}</span>

	/**
	 * Returns the result of an XSL Transformation as a list of JDOM
	 * nodes.
	 * &lt;p&gt;
	 * If the result of the transformation is a JDOM document,
	 * this method converts it into a list of JDOM nodes; any
	 * subsequent call to {@link #getDocument} will return
	 * &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
	 *
	 * @return the transformation result as a (possibly empty) list of
	 *         JDOM nodes (Elements, Texts, Comments, PIs...).
	 */
	public List&lt;Content&gt; getResult() {
<span class="fc" id="L183">		List&lt;Content&gt; nodes = Collections.emptyList();</span>

		// Retrieve result from the document builder if not set.
<span class="fc" id="L186">		this.retrieveResult();</span>

<span class="fc bfc" id="L188" title="All 2 branches covered.">		if (resultlist != null) {</span>
<span class="fc" id="L189">			nodes = resultlist;</span>
		}
		else {
<span class="fc bfc" id="L192" title="All 4 branches covered.">			if (resultdoc != null &amp;&amp; queried == false) {</span>
<span class="fc" id="L193">				List&lt;Content&gt; content = resultdoc.getContent();</span>
<span class="fc" id="L194">				nodes = new ArrayList&lt;Content&gt;(content.size());</span>

<span class="fc bfc" id="L196" title="All 2 branches covered.">				while (content.size() != 0)</span>
				{
<span class="fc" id="L198">					Content o = content.remove(0);</span>
<span class="fc" id="L199">					nodes.add(o);</span>
<span class="fc" id="L200">				}</span>
<span class="fc" id="L201">				resultlist = nodes;</span>
<span class="fc" id="L202">				resultdoc = null;</span>
			}
		}
<span class="fc" id="L205">		queried = true;</span>

<span class="fc" id="L207">		return (nodes);</span>
	}

	/**
	 * Sets the document produced as result of an XSL Transformation.
	 * &lt;p&gt;
	 * &lt;strong&gt;Note&lt;/strong&gt;: This method shall be used by the
	 * {@link javax.xml.transform.Transformer} implementations that
	 * natively support JDOM to directly set the transformation
	 * result rather than considering this object as a
	 * {@link SAXResult}.  Applications should &lt;i&gt;not&lt;/i&gt; use this
	 * method.&lt;/p&gt;
	 *
	 * @param  document   the JDOM document result of a transformation.
	 *
	 * @see    #setResult
	 * @see    #getDocument
	 */
	public void setDocument(Document document) {
<span class="fc" id="L226">		this.resultdoc  = document;</span>
<span class="fc" id="L227">		this.resultlist = null;</span>
<span class="fc" id="L228">		this.queried = false;</span>
<span class="fc" id="L229">	}</span>

	/**
	 * Returns the result of an XSL Transformation as a JDOM document.
	 * &lt;p&gt;
	 * If the result of the transformation is a list of nodes,
	 * this method attempts to convert it into a JDOM document. If
	 * successful, any subsequent call to {@link #getResult} will
	 * return an empty list.&lt;/p&gt;
	 * &lt;p&gt;
	 * &lt;strong&gt;Warning&lt;/strong&gt;: The XSLT 1.0 specification states that
	 * the output of an XSL transformation is not a well-formed XML
	 * document but a list of nodes. Applications should thus use
	 * {@link #getResult} instead of this method or at least expect
	 * &lt;code&gt;null&lt;/code&gt; documents to be returned.
	 *
	 * @return the transformation result as a JDOM document or
	 *         &lt;code&gt;null&lt;/code&gt; if the result of the transformation
	 *         can not be converted into a well-formed document.
	 *
	 * @see    #getResult
	 */
	public Document getDocument() {
<span class="fc" id="L252">		Document doc = null;</span>

		// Retrieve result from the document builder if not set.
<span class="fc" id="L255">		this.retrieveResult();</span>

<span class="fc bfc" id="L257" title="All 2 branches covered.">		if (resultdoc != null) {</span>
<span class="fc" id="L258">			doc = resultdoc;</span>
		}
		else {
<span class="fc bfc" id="L261" title="All 4 branches covered.">			if (resultlist != null &amp;&amp; (queried == false)) {</span>
				// Try to create a document from the result nodes
				try {
<span class="fc" id="L264">					JDOMFactory f = this.getFactory();</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">					if (f == null) { f = new DefaultJDOMFactory(); }</span>

<span class="fc" id="L267">					doc = f.document(null);</span>
<span class="fc" id="L268">					doc.setContent(resultlist);</span>

<span class="fc" id="L270">					resultdoc = doc;</span>
<span class="fc" id="L271">					resultlist = null;</span>
				}
<span class="fc" id="L273">				catch (RuntimeException ex1) {</span>
					// Some of the result nodes are not valid children of a
					// Document node. =&gt; return null.
<span class="fc" id="L276">					return null;</span>
<span class="fc" id="L277">				}</span>
			}
		}
<span class="fc" id="L280">		queried = true;</span>

<span class="fc" id="L282">		return (doc);</span>
	}

	/**
	 * Sets a custom JDOMFactory to use when building the
	 * transformation result. Use a custom factory to build the tree
	 * with your own subclasses of the JDOM classes.
	 *
	 * @param  factory   the custom &lt;code&gt;JDOMFactory&lt;/code&gt; to use or
	 *                   &lt;code&gt;null&lt;/code&gt; to use the default JDOM
	 *                   classes.
	 *
	 * @see    #getFactory
	 */
	public void setFactory(JDOMFactory factory) {
<span class="fc" id="L297">		this.factory = factory;</span>
<span class="fc" id="L298">	}</span>

	/**
	 * Returns the custom JDOMFactory used to build the transformation
	 * result.
	 *
	 * @return the custom &lt;code&gt;JDOMFactory&lt;/code&gt; used to build the
	 *         transformation result or &lt;code&gt;null&lt;/code&gt; if the
	 *         default JDOM classes are being used.
	 *
	 * @see    #setFactory
	 */
	public JDOMFactory getFactory() {
<span class="fc" id="L311">		return this.factory;</span>
	}

	/**
	 * Checks whether a transformation result has been set and, if not,
	 * retrieves the result tree being built by the document builder.
	 */
	private void retrieveResult() {
<span class="fc bfc" id="L319" title="All 4 branches covered.">		if (resultlist == null &amp;&amp; resultdoc == null) {</span>
<span class="fc" id="L320">			this.setResult(((DocumentBuilder)this.getHandler()).getResult());</span>
		}
<span class="fc" id="L322">	}</span>

	//-------------------------------------------------------------------------
	// SAXResult overwritten methods
	//-------------------------------------------------------------------------

	/**
	 * Sets the target to be a SAX2 ContentHandler.
	 *
	 * @param handler Must be a non-null ContentHandler reference.
	 */
	@Override
	public void setHandler(ContentHandler handler) {
		// Do Nothing
<span class="fc" id="L336">	}</span>

	/**
	 * Sets the SAX2 LexicalHandler for the output.
	 * &lt;p&gt;
	 * This is needed to handle XML comments and the like.  If the
	 * lexical handler is not set, an attempt should be made by the
	 * transformer to cast the ContentHandler to a LexicalHandler.&lt;/p&gt;
	 *
	 * @param handler A non-null LexicalHandler for
	 *                handling lexical parse events.
	 */
	@Override
	public void setLexicalHandler(LexicalHandler handler) {
		// Ignore.
<span class="fc" id="L351">	}</span>


	//=========================================================================
	// FragmentHandler nested class
	//=========================================================================

	private static class FragmentHandler extends SAXHandler {
		/**
		 * A dummy root element required by SAXHandler that can only
		 * cope with well-formed documents.
		 */
<span class="fc" id="L363">		private Element dummyRoot = new Element(&quot;root&quot;, null, null);</span>

		/**
		 * Public constructor.
		 * @param factory The Factory to use to create content instances
		 */
		public FragmentHandler(JDOMFactory factory) {
<span class="fc" id="L370">			super(factory);</span>

			// Add a dummy root element to the being-built document as XSL
			// transformation can output node lists instead of well-formed
			// documents.
<span class="fc" id="L375">			this.pushElement(dummyRoot);</span>
<span class="fc" id="L376">		}</span>

		/**
		 * Returns the result of an XSL Transformation.
		 *
		 * @return the transformation result as a (possibly empty) list of
		 *         JDOM nodes (Elements, Texts, Comments, PIs...).
		 */
		public List&lt;Content&gt; getResult() {
			// Flush remaining text content in case the last text segment is
			// outside an element.
			try {
<span class="fc" id="L388">				this.flushCharacters();</span>
			}
<span class="pc" id="L390">			catch (SAXException e) { /* Ignore... */  }</span>
<span class="fc" id="L391">			return this.getDetachedContent(dummyRoot);</span>
		}

		/**
		 * Returns the content of a JDOM Element detached from it.
		 *
		 * @param  elt   the element to get the content from.
		 *
		 * @return a (possibly empty) list of JDOM nodes, detached from
		 *         their parent.
		 */
		private List&lt;Content&gt; getDetachedContent(Element elt) {
<span class="fc" id="L403">			List&lt;Content&gt; content = elt.getContent();</span>
<span class="fc" id="L404">			List&lt;Content&gt; nodes   = new ArrayList&lt;Content&gt;(content.size());</span>

<span class="fc bfc" id="L406" title="All 2 branches covered.">			while (content.size() != 0)</span>
			{
<span class="fc" id="L408">				Content o = content.remove(0);</span>
<span class="fc" id="L409">				nodes.add(o);</span>
<span class="fc" id="L410">			}</span>
<span class="fc" id="L411">			return (nodes);</span>
		}
	}

	//=========================================================================
	// DocumentBuilder inner class
	//=========================================================================

	private class DocumentBuilder extends XMLFilterImpl
	implements LexicalHandler {
		/**
		 * The actual JDOM document builder.
		 */
<span class="fc" id="L424">		private FragmentHandler saxHandler = null;</span>

		/**
		 * Whether the startDocument event was received. Some XSLT
		 * processors such as Oracle's do not fire this event.
		 */
<span class="fc" id="L430">		private boolean startDocumentReceived = false;</span>

		/**
		 * Public default constructor.
		 */
<span class="fc" id="L435">		public DocumentBuilder() { }</span>

		/**
		 * Returns the result of an XSL Transformation.
		 *
		 * @return the transformation result as a (possibly empty) list of
		 *         JDOM nodes (Elements, Texts, Comments, PIs...) or
		 *         &lt;code&gt;null&lt;/code&gt; if no new transformation occurred
		 *         since the result of the previous one was returned.
		 */
		public List&lt;Content&gt; getResult() {
<span class="fc" id="L446">			List&lt;Content&gt; mresult = null;</span>

<span class="fc bfc" id="L448" title="All 2 branches covered.">			if (this.saxHandler != null) {</span>
				// Retrieve result from SAX content handler.
<span class="fc" id="L450">				mresult = this.saxHandler.getResult();</span>

				// Detach the (non-reusable) SAXHandler instance.
<span class="fc" id="L453">				this.saxHandler = null;</span>

				// And get ready for the next transformation.
<span class="fc" id="L456">				this.startDocumentReceived = false;</span>
			}
<span class="fc" id="L458">			return mresult;</span>
		}

		private void ensureInitialization() throws SAXException {
			// Trigger document initialization if XSLT processor failed to
			// fire the startDocument event.
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">			if (this.startDocumentReceived == false) {</span>
<span class="nc" id="L465">				this.startDocument();</span>
			}
<span class="fc" id="L467">		}</span>

		//-----------------------------------------------------------------------
		// XMLFilterImpl overwritten methods
		//-----------------------------------------------------------------------

		/**
		 * &lt;i&gt;[SAX ContentHandler interface support]&lt;/i&gt; Processes a
		 * start of document event.
		 * &lt;p&gt;
		 * This implementation creates a new JDOM document builder and
		 * marks the current result as &quot;under construction&quot;.&lt;/p&gt;
		 *
		 * @throws SAXException   if any error occurred while creating
		 *                        the document builder.
		 */
		@Override
		public void startDocument() throws SAXException {
<span class="fc" id="L485">			this.startDocumentReceived = true;</span>

			// Reset any previously set result.
<span class="fc" id="L488">			setResult(null);</span>

			// Create the actual JDOM document builder and register it as
			// ContentHandler on the superclass (XMLFilterImpl): this
			// implementation will take care of propagating the LexicalHandler
			// events.
<span class="fc" id="L494">			this.saxHandler = new FragmentHandler(getFactory());</span>
<span class="fc" id="L495">			super.setContentHandler(this.saxHandler);</span>

			// And propagate event.
<span class="fc" id="L498">			super.startDocument();</span>
<span class="fc" id="L499">		}</span>

		/**
		 * &lt;i&gt;[SAX ContentHandler interface support]&lt;/i&gt; Receives
		 * notification of the beginning of an element.
		 * &lt;p&gt;
		 * This implementation ensures that startDocument() has been
		 * called prior processing an element.
		 *
		 * @param  nsURI       the Namespace URI, or the empty string if
		 *                     the element has no Namespace URI or if
		 *                     Namespace processing is not being performed.
		 * @param  localName   the local name (without prefix), or the
		 *                     empty string if Namespace processing is
		 *                     not being performed.
		 * @param  qName       the qualified name (with prefix), or the
		 *                     empty string if qualified names are not
		 *                     available.
		 * @param  atts        The attributes attached to the element.  If
		 *                     there are no attributes, it shall be an
		 *                     empty Attributes object.
		 *
		 * @throws SAXException   if any error occurred while creating
		 *                        the document builder.
		 */
		@Override
		public void startElement(String nsURI, String localName, String qName,
				Attributes atts) throws SAXException
				{
<span class="fc" id="L528">			this.ensureInitialization();</span>
<span class="fc" id="L529">			super.startElement(nsURI, localName, qName, atts);</span>
<span class="fc" id="L530">				}</span>

		/**
		 * &lt;i&gt;[SAX ContentHandler interface support]&lt;/i&gt; Begins the
		 * scope of a prefix-URI Namespace mapping.
		 */
		@Override
		public void startPrefixMapping(String prefix, String uri)
				throws SAXException {
<span class="fc" id="L539">			this.ensureInitialization();</span>
<span class="fc" id="L540">			super.startPrefixMapping(prefix, uri);</span>
<span class="fc" id="L541">		}</span>

		/**
		 * &lt;i&gt;[SAX ContentHandler interface support]&lt;/i&gt; Receives
		 * notification of character data.
		 */
		@Override
		public void characters(char ch[], int start, int length)
				throws SAXException {
<span class="fc" id="L550">			this.ensureInitialization();</span>
<span class="fc" id="L551">			super.characters(ch, start, length);</span>
<span class="fc" id="L552">		}</span>

		/**
		 * &lt;i&gt;[SAX ContentHandler interface support]&lt;/i&gt; Receives
		 * notification of ignorable whitespace in element content.
		 */
		@Override
		public void ignorableWhitespace(char ch[], int start, int length)
				throws SAXException {
<span class="nc" id="L561">			this.ensureInitialization();</span>
<span class="nc" id="L562">			super.ignorableWhitespace(ch, start, length);</span>
<span class="nc" id="L563">		}</span>

		/**
		 * &lt;i&gt;[SAX ContentHandler interface support]&lt;/i&gt; Receives
		 * notification of a processing instruction.
		 */
		@Override
		public void processingInstruction(String target, String data)
				throws SAXException {
<span class="fc" id="L572">			this.ensureInitialization();</span>
<span class="fc" id="L573">			super.processingInstruction(target, data);</span>
<span class="fc" id="L574">		}</span>

		/**
		 * &lt;i&gt;[SAX ContentHandler interface support]&lt;/i&gt; Receives
		 * notification of a skipped entity.
		 */
		@Override
		public void skippedEntity(String name) throws SAXException {
<span class="nc" id="L582">			this.ensureInitialization();</span>
<span class="nc" id="L583">			super.skippedEntity(name);</span>
<span class="nc" id="L584">		}</span>

		//-----------------------------------------------------------------------
		// LexicalHandler interface support
		//-----------------------------------------------------------------------

		/**
		 * &lt;i&gt;[SAX LexicalHandler interface support]&lt;/i&gt; Reports the
		 * start of DTD declarations, if any.
		 *
		 * @param  name       the document type name.
		 * @param  publicId   the declared public identifier for the
		 *                    external DTD subset, or &lt;code&gt;null&lt;/code&gt;
		 *                    if none was declared.
		 * @param  systemId   the declared system identifier for the
		 *                    external DTD subset, or &lt;code&gt;null&lt;/code&gt;
		 *                    if none was declared.
		 *
		 * @throws SAXException   The application may raise an exception.
		 */
		@Override
		public void startDTD(String name, String publicId, String systemId)
				throws SAXException {
<span class="nc" id="L607">			this.ensureInitialization();</span>
<span class="nc" id="L608">			this.saxHandler.startDTD(name, publicId, systemId);</span>
<span class="nc" id="L609">		}</span>

		/**
		 * &lt;i&gt;[SAX LexicalHandler interface support]&lt;/i&gt; Reports the end
		 * of DTD declarations.
		 *
		 * @throws SAXException   The application may raise an exception.
		 */
		@Override
		public void endDTD() throws SAXException {
<span class="nc" id="L619">			this.saxHandler.endDTD();</span>
<span class="nc" id="L620">		}</span>

		/**
		 * &lt;i&gt;[SAX LexicalHandler interface support]&lt;/i&gt; Reports the
		 * beginning of some internal and external XML entities.
		 *
		 * @param  name   the name of the entity.  If it is a parameter
		 *                entity, the name will begin with '%', and if it
		 *                is the external DTD subset, it will be &quot;[dtd]&quot;.
		 *
		 * @throws SAXException   The application may raise an exception.
		 */
		@Override
		public void startEntity(String name) throws SAXException {
<span class="nc" id="L634">			this.ensureInitialization();</span>
<span class="nc" id="L635">			this.saxHandler.startEntity(name);</span>
<span class="nc" id="L636">		}</span>

		/**
		 * &lt;i&gt;[SAX LexicalHandler interface support]&lt;/i&gt; Reports the end
		 * of an entity.
		 *
		 * @param  name   the name of the entity that is ending.
		 *
		 * @throws SAXException   The application may raise an exception.
		 */
		@Override
		public void endEntity(String name) throws SAXException {
<span class="nc" id="L648">			this.saxHandler.endEntity(name);</span>
<span class="nc" id="L649">		}</span>

		/**
		 * &lt;i&gt;[SAX LexicalHandler interface support]&lt;/i&gt; Reports the
		 * start of a CDATA section.
		 *
		 * @throws SAXException   The application may raise an exception.
		 */
		@Override
		public void startCDATA() throws SAXException {
<span class="fc" id="L659">			this.ensureInitialization();</span>
<span class="fc" id="L660">			this.saxHandler.startCDATA();</span>
<span class="fc" id="L661">		}</span>

		/**
		 * &lt;i&gt;[SAX LexicalHandler interface support]&lt;/i&gt; Reports the end
		 * of a CDATA section.
		 *
		 * @throws SAXException   The application may raise an exception.
		 */
		@Override
		public void endCDATA() throws SAXException {
<span class="fc" id="L671">			this.saxHandler.endCDATA();</span>
<span class="fc" id="L672">		}</span>

		/**
		 * &lt;i&gt;[SAX LexicalHandler interface support]&lt;/i&gt; Reports an XML
		 * comment anywhere in the document.
		 *
		 * @param  ch     an array holding the characters in the comment.
		 * @param  start  the starting position in the array.
		 * @param  length the number of characters to use from the array.
		 *
		 * @throws SAXException   The application may raise an exception.
		 */
		@Override
		public void comment(char ch[], int start, int length)
				throws SAXException {
<span class="fc" id="L687">			this.ensureInitialization();</span>
<span class="fc" id="L688">			this.saxHandler.comment(ch, start, length);</span>
<span class="fc" id="L689">		}</span>
	}
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.0.201403182114</span></div></body></html>